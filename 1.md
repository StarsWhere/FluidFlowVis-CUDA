好的，我已经仔细分析了您的需求和提供的代码文件。您要求在现有代码（以`682123bf8bc7557e58f7ca9bee96c46ae341d3cb`版本为基础）之上，完成几项额外的功能和修复，并整合所有更改，最终提供可以直接覆盖使用的、完整的 Python 文件。

以下是根据您的所有要求修改后的完整代码文件。未列出的文件表示它们无需任何改动。

### **无更改的文件**

以下文件无需修改，您可以保留原始版本：
*   `__init__.py` (所有同名文件)
*   `computation_core.py`
*   `compute_handler.py`
*   `config_handler.py`
*   `dialogs.py`
*   `formula_engine.py`
*   `gpu_utils.py`
*   `help_dialog.py`
*   `logger.py`
*   `playback_handler.py`
*   `rendering_core.py`
*   `statistics_calculator.py`

---
### **需要修改的文件**

以下是所有经过修改的文件的完整内容。

--- START OF FILE constants.py ---
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
项目共享常量与枚举
"""
from enum import Enum

class VectorPlotType(Enum):
    """矢量图的绘图类型"""
    STREAMLINE = "流线图 (Streamline)"
    QUIVER = "矢量图 (Quiver)"

    @classmethod
    def from_str(cls, s: str):
        for item in cls:
            if item.value == s:
                return item
        return cls.STREAMLINE # 默认值

class StreamlineColor(Enum):
    """流线图的着色依据"""
    MAGNITUDE = "速度大小"
    U_COMPONENT = "U分量"
    V_COMPONENT = "V分量"
    BLACK = "黑色"

    @classmethod
    def from_str(cls, s: str):
        for item in cls:
            if item.value == s:
                return item
        return cls.MAGNITUDE # 默认值

class PickerMode(Enum):
    """颜色拾取器/交互模式的枚举"""
    VMIN = "vmin"
    VMAX = "vmax"
    TIMESERIES = "timeseries"
    PROFILE_START = "profile_start" # 新增: 剖面图起点
    PROFILE_END = "profile_end"     # 新增: 剖面图终点
```
--- END OF FILE constants.py ---

--- START OF FILE data_manager.py ---
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import os
import pandas as pd
import logging
import sqlite3
from typing import Optional, List, Dict, Any, Generator, Tuple
from collections import OrderedDict
from PyQt6.QtCore import QObject, pyqtSignal

logger = logging.getLogger(__name__)

DB_FILENAME = "_intervis_data.db"
METADATA_TABLE_NAME = "intervis_metadata"
CUSTOM_CONSTANTS_TABLE_NAME = "intervis_custom_constants"

class DataManager(QObject):
    """
    负责数据库的连接、查询和数据缓存。
    """
    error_occurred = pyqtSignal(str)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.project_directory: Optional[str] = None
        self.db_path: Optional[str] = None
        
        self.cache: OrderedDict[int, pd.DataFrame] = OrderedDict()
        self.cache_max_size = 100
        
        self._variables: Optional[List[str]] = None
        self._frame_count: Optional[int] = None
        
        self.global_stats: Dict[str, float] = {}
        self.custom_global_formulas: Dict[str, str] = {}
        
        self.global_filter_clause: str = ""

    def setup_project_directory(self, directory: str) -> bool:
        """设置项目目录并检查数据库状态。"""
        self.project_directory = directory
        self.db_path = os.path.join(self.project_directory, DB_FILENAME)
        
        if not os.path.isdir(self.project_directory):
            msg = f"项目目录不存在: {self.project_directory}"
            logger.error(msg)
            self.error_occurred.emit(msg)
            return False
        
        self.clear_all()
        logger.info(f"项目目录已设置为: {self.project_directory}")
        return True

    def is_database_ready(self) -> bool:
        """检查数据库文件是否存在且有效。"""
        if self.db_path and os.path.exists(self.db_path):
            try:
                conn = sqlite3.connect(self.db_path)
                cursor = conn.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='timeseries_data';")
                if cursor.fetchone() is None:
                    conn.close(); return False
                conn.close(); return True
            except sqlite3.DatabaseError:
                logger.warning(f"数据库文件 {self.db_path} 已损坏或无效。")
                return False
        return False
        
    def get_db_connection(self) -> sqlite3.Connection:
        """返回一个新的数据库连接。调用者负责关闭连接。"""
        if not self.db_path: raise ConnectionError("数据库路径未设置。")
        return sqlite3.connect(self.db_path, timeout=10)
    
    def create_database_tables(self, conn: sqlite3.Connection):
        """创建所有必需的表，如果它们不存在的话。"""
        cursor = conn.cursor()
        # Metadata table for storing global stats
        cursor.execute(f"""
        CREATE TABLE IF NOT EXISTS {METADATA_TABLE_NAME} (
            key TEXT PRIMARY KEY,
            value REAL NOT NULL
        );
        """)
        # Custom constants definitions table
        cursor.execute(f"""
        CREATE TABLE IF NOT EXISTS {CUSTOM_CONSTANTS_TABLE_NAME} (
            id INTEGER PRIMARY KEY,
            definition TEXT NOT NULL UNIQUE
        );
        """)
        conn.commit()
        logger.info("数据库元数据和自定义常量表已确认存在。")

    def post_import_setup(self):
        """导入完成后，强制重新加载元数据。"""
        self.refresh_schema_info()
        self.load_global_stats() # Load stats from db
        logger.info("数据库设置完成。")

    def refresh_schema_info(self):
        """当数据库表结构发生变化时（如添加列），强制刷新元数据。"""
        self._variables = None; self._frame_count = None
        self.get_variables(); self.get_frame_count()
        logger.info("DataManager schema info has been refreshed.")

    def set_global_filter(self, filter_text: str):
        """设置并验证全局过滤器。"""
        if not filter_text.strip():
            self.global_filter_clause = ""
            logger.info("全局过滤器已清除。")
            return
        
        # 非常基础的验证，防止一些明显的错误
        if 'drop' in filter_text.lower() or 'delete' in filter_text.lower():
             raise ValueError("过滤器不允许包含 'DROP' 或 'DELETE'。")
        
        self.global_filter_clause = f"AND ({filter_text})"
        logger.info(f"全局过滤器已设置为: {self.global_filter_clause}")
        # 清空缓存，因为过滤条件已改变
        self.cache.clear()

    def get_frame_data(self, frame_index: int) -> Optional[pd.DataFrame]:
        # 缓存键现在必须包含过滤器，以避免混淆
        cache_key = (frame_index, self.global_filter_clause)
        if not (0 <= frame_index < self.get_frame_count()): return None
        if cache_key in self.cache:
            self.cache.move_to_end(cache_key)
            return self.cache[cache_key]
        
        try:
            conn = self.get_db_connection()
            all_known_vars = self.get_variables()
            if not all_known_vars: return pd.DataFrame()

            cols_to_select = ", ".join([f'"{var}"' for var in all_known_vars])
            query = f"SELECT {cols_to_select} FROM timeseries_data WHERE frame_index = ? {self.global_filter_clause}"
            
            data = pd.read_sql_query(query, conn, params=(frame_index,))
            conn.close()

            self.cache[cache_key] = data
            self._enforce_cache_limit()
            return data
        except Exception as e:
            msg = f"从数据库加载帧 {frame_index} 数据失败: {e}"
            logger.error(msg, exc_info=True)
            self.error_occurred.emit(f"加载帧 {frame_index} 失败 (可能由于过滤器语法错误)。\n错误: {e}")
            return None

    def get_time_averaged_data(self, start_frame: int, end_frame: int) -> Optional[pd.DataFrame]:
        """计算并返回指定时间范围内的平均场。"""
        try:
            conn = self.get_db_connection()
            variables = self.get_variables()
            avg_cols = ", ".join([f'AVG("{var}") as "{var}"' for var in variables])
            
            # 我们需要x和y坐标来构建网格，所以也对它们进行平均（虽然它们可能不随时间变化）
            query = f"""
                SELECT AVG(x) as x, AVG(y) as y, {avg_cols}
                FROM timeseries_data
                WHERE frame_index BETWEEN ? AND ? {self.global_filter_clause}
                GROUP BY x, y
            """
            
            df = pd.read_sql_query(query, conn, params=(start_frame, end_frame))
            conn.close()
            return df
        except Exception as e:
            msg = f"计算时间平均场失败: {e}"
            logger.error(msg, exc_info=True)
            self.error_occurred.emit(f"时间平均计算失败 (可能由于过滤器语法错误)。\n错误: {e}")
            return None

    def get_timeseries_at_point(self, variable: str, point_coords: Tuple[float, float], tolerance: float = 0.05) -> Optional[pd.DataFrame]:
        """使用'探针盒'方法获取一个点的时间序列数据。"""
        if variable not in self.get_variables():
            raise ValueError(f"变量 '{variable}' 不存在。")
        
        x, y = point_coords
        x_min, x_max = x - tolerance, x + tolerance
        y_min, y_max = y - tolerance, y + tolerance

        try:
            conn = self.get_db_connection()
            query = f"""
                SELECT timestamp, AVG("{variable}") as "{variable}"
                FROM timeseries_data
                WHERE x BETWEEN ? AND ? AND y BETWEEN ? AND ? {self.global_filter_clause}
                GROUP BY frame_index
                ORDER BY timestamp
            """
            df = pd.read_sql_query(query, conn, params=(x_min, x_max, y_min, y_max))
            conn.close()
            return df
        except Exception as e:
            msg = f"获取时间序列数据失败: {e}"
            logger.error(msg, exc_info=True)
            self.error_occurred.emit(f"时间序列查询失败。\n错误: {e}")
            return None

    def _enforce_cache_limit(self):
        while len(self.cache) > self.cache_max_size:
            self.cache.popitem(last=False)

    def set_cache_size(self, size: int):
        self.cache_max_size = max(1, size)
        self._enforce_cache_limit()
        logger.info(f"缓存大小已设置为: {self.cache_max_size}")

    def get_frame_count(self) -> int:
        if self._frame_count is None:
            if not self.is_database_ready(): return 0
            try:
                conn = self.get_db_connection()
                result = conn.execute("SELECT MAX(frame_index) + 1 FROM timeseries_data;").fetchone()
                conn.close()
                self._frame_count = result[0] if result and result[0] is not None else 0
            except Exception: self._frame_count = 0
        return self._frame_count

    def get_frame_info(self, i: int) -> Optional[Dict[str, Any]]: 
        if not (0 <= i < self.get_frame_count()): return None
        try:
            conn = self.get_db_connection()
            ts = conn.execute("SELECT timestamp FROM timeseries_data WHERE frame_index = ? LIMIT 1;", (i,)).fetchone()
            conn.close()
            return {'path': f'db_frame_{i}', 'timestamp': ts[0] if ts else i}
        except Exception: return {'path': f'db_frame_{i}', 'timestamp': i}

    def get_cache_info(self) -> Dict: return {'size': len(self.cache), 'max_size': self.cache_max_size}

    def get_database_info(self) -> Dict[str, Any]:
        """返回数据库的概览信息。"""
        return {
            "db_path": self.db_path,
            "is_ready": self.is_database_ready(),
            "frame_count": self.get_frame_count(),
            "variables": self.get_variables(),
            "global_filter": self.global_filter_clause
        }

    def get_variables(self) -> List[str]:
        if self._variables is None:
            if not self.is_database_ready(): return []
            try:
                conn = self.get_db_connection()
                cursor = conn.execute("PRAGMA table_info(timeseries_data);")
                all_cols = [row[1] for row in cursor.fetchall()]
                conn.close()
                excluded_cols = {'id', 'frame_index', 'timestamp'}
                self._variables = sorted([col for col in all_cols if col not in excluded_cols])
            except Exception: self._variables = []
        return self._variables

    def save_global_stats(self, stats: Dict[str, float]):
        """将统计数据保存或更新到元数据表中。"""
        if not self.db_path: return
        try:
            conn = self.get_db_connection()
            cursor = conn.cursor()
            data_to_insert = list(stats.items())
            cursor.executemany(f"INSERT OR REPLACE INTO {METADATA_TABLE_NAME} (key, value) VALUES (?, ?)", data_to_insert)
            conn.commit()
            conn.close()
            logger.info(f"成功将 {len(stats)} 条统计数据保存到数据库。")
            # 更新内存中的副本
            self.global_stats.update(stats)
        except Exception as e:
            logger.error(f"保存全局统计数据失败: {e}", exc_info=True)

    def load_global_stats(self):
        """从数据库加载所有全局统计数据。"""
        if not self.is_database_ready(): return
        try:
            conn = self.get_db_connection()
            cursor = conn.execute(f"SELECT key, value FROM {METADATA_TABLE_NAME}")
            self.global_stats = dict(cursor.fetchall())
            conn.close()
            logger.info(f"从数据库加载了 {len(self.global_stats)} 条全局统计数据。")
        except Exception as e:
            logger.error(f"加载全局统计数据失败: {e}", exc_info=True)
            self.global_stats = {}

    def save_custom_definitions(self, definitions: List[str]):
        if not self.db_path: return
        try:
            conn = self.get_db_connection()
            cursor = conn.cursor()
            cursor.execute(f"DELETE FROM {CUSTOM_CONSTANTS_TABLE_NAME}") # Clear old definitions
            data_to_insert = [(d,) for d in definitions]
            cursor.executemany(f"INSERT INTO {CUSTOM_CONSTANTS_TABLE_NAME} (definition) VALUES (?)", data_to_insert)
            conn.commit()
            conn.close()
            logger.info(f"成功将 {len(definitions)} 条自定义常量定义保存到数据库。")
        except Exception as e:
            logger.error(f"保存自定义常量定义失败: {e}", exc_info=True)

    def load_custom_definitions(self) -> List[str]:
        if not self.is_database_ready(): return []
        try:
            conn = self.get_db_connection()
            cursor = conn.execute(f"SELECT definition FROM {CUSTOM_CONSTANTS_TABLE_NAME} ORDER BY id")
            definitions = [row[0] for row in cursor.fetchall()]
            conn.close()
            logger.info(f"从数据库加载了 {len(definitions)} 条自定义常量定义。")
            return definitions
        except Exception as e:
            logger.error(f"加载自定义常量定义失败: {e}", exc_info=True)
            return []

    def clear_all(self):
        self._variables = None; self._frame_count = None
        self.cache.clear(); self.clear_global_stats()
        self.global_filter_clause = ""
        logger.info("DataManager 状态已清除。")

    def clear_global_stats(self):
        self.global_stats.clear(); self.custom_global_formulas.clear()
        logger.info("内存中的全局统计数据已清除。")
```
--- END OF FILE data_manager.py ---

--- START OF FILE export_handler.py ---
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
导出功能处理器
"""
import os
import logging
from datetime import datetime
from typing import Optional

from PyQt6.QtWidgets import QMessageBox, QFileDialog
from src.visualization.video_exporter import VideoExportDialog
from src.ui.dialogs import BatchExportDialog, ConfigSelectionDialog, ImportDialog as ProgressDialog
from src.core.workers import BatchExportWorker, DataExportWorker

logger = logging.getLogger(__name__)

class ExportHandler:
    """处理所有与导出图像、视频和数据相关的逻辑。"""

    def __init__(self, main_window, ui, data_manager, config_handler):
        self.main_window = main_window
        self.ui = ui
        self.dm = data_manager
        self.config_handler = config_handler

        self.output_dir = self.main_window.output_dir
        self.settings_dir = self.config_handler.settings_dir

        self.batch_export_dialog: Optional[BatchExportDialog] = None
        self.batch_export_worker: Optional[BatchExportWorker] = None
        self.data_export_worker: Optional[DataExportWorker] = None

    def connect_signals(self):
        self.ui.export_img_btn.clicked.connect(self.export_image)
        self.ui.export_vid_btn.clicked.connect(self.export_video)
        self.ui.batch_export_btn.clicked.connect(self.start_batch_export)
        self.ui.set_output_dir_action.triggered.connect(self._change_output_directory)
        self.ui.change_output_dir_btn.clicked.connect(self._change_output_directory)
        self.ui.export_data_csv_btn.clicked.connect(self.export_filtered_data_to_csv)

    def set_output_dir(self, directory: str):
        self.output_dir = directory
        self.ui.output_dir_line_edit.setText(self.output_dir)

    def _change_output_directory(self):
        new_dir = QFileDialog.getExistingDirectory(self.main_window, "选择输出目录", self.output_dir)
        if new_dir and new_dir != self.output_dir:
            self.set_output_dir(new_dir)
            self.main_window.settings.setValue("output_directory", new_dir)

    def export_image(self):
        fname = os.path.join(self.output_dir, f"frame_{self.main_window.current_frame_index:05d}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png")
        if self.ui.plot_widget.save_figure(fname, self.ui.export_dpi.value()):
            QMessageBox.information(self.main_window, "成功", f"图片已保存到:\n{fname}")
        else:
            QMessageBox.warning(self.main_window, "失败", "图片保存失败。")

    def export_video(self):
        s_f, e_f = self.ui.video_start_frame.value(), self.ui.video_end_frame.value()
        if s_f >= e_f:
            QMessageBox.warning(self.main_window, "参数错误", "起始帧必须小于结束帧"); return
        
        config_name = os.path.splitext(os.path.basename(self.config_handler.current_config_file or "default"))[0]
        fname = os.path.join(self.output_dir, f"video_{config_name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.mp4")
        
        current_config = self.config_handler.get_current_config()
        
        p_conf = {
            'x_axis_formula': current_config['axes'].get('x_formula') or 'x',
            'y_axis_formula': current_config['axes'].get('y_formula') or 'y',
            'chart_title': current_config['axes'].get('title', ''),
            'use_gpu': self.ui.gpu_checkbox.isChecked(), 
            'heatmap_config': current_config['heatmap'], 
            'contour_config': current_config['contour'],
            'vector_config': current_config.get('vector', {}),
            'export_dpi': self.ui.export_dpi.value(),
            'grid_resolution': (self.ui.video_grid_w.value(), self.ui.video_grid_h.value()),
            'global_scope': self.dm.global_stats
        }
        VideoExportDialog(self.main_window, self.dm, p_conf, fname, s_f, e_f, self.ui.video_fps.value()).exec()

    def start_batch_export(self):
        if self.dm.get_frame_count() == 0:
            QMessageBox.warning(self.main_window, "无数据", "请先加载数据再执行批量导出。"); return
            
        dialog = ConfigSelectionDialog(self.settings_dir, self.main_window)
        if not dialog.exec(): return

        config_files = dialog.selected_files()
        if not config_files:
            QMessageBox.information(self.main_window, "无选择", "您没有选择任何配置文件。")
            return

        self.batch_export_dialog = BatchExportDialog(self.main_window)
        self.batch_export_worker = BatchExportWorker(config_files, self.dm, self.output_dir)
        
        self.batch_export_worker.progress.connect(self.batch_export_dialog.update_progress)
        self.batch_export_worker.log_message.connect(self.batch_export_dialog.add_log)
        self.batch_export_worker.summary_ready.connect(self.batch_export_dialog.on_finish)
        self.batch_export_worker.summary_ready.connect(self._on_batch_export_summary_ready)
        self.batch_export_worker.finished.connect(self._on_batch_export_thread_finished)

        self.batch_export_dialog.show()
        self.batch_export_worker.start()

    def export_filtered_data_to_csv(self):
        if self.dm.get_frame_count() == 0:
            QMessageBox.warning(self.main_window, "无数据", "请先加载数据再导出。"); return
        
        default_name = f"filtered_data_{datetime.now().strftime('%Y%m%d')}.csv"
        filepath, _ = QFileDialog.getSaveFileName(self.main_window, "导出数据到CSV", os.path.join(self.output_dir, default_name), "CSV 文件 (*.csv)")
        if not filepath: return
        
        progress = ProgressDialog(self.main_window, "正在导出数据...")
        filter_clause = self.dm.global_filter_clause if self.ui.filter_enabled_checkbox.isChecked() else ""
        
        self.data_export_worker = DataExportWorker(self.dm, filepath, filter_clause)
        self.data_export_worker.progress.connect(progress.update_progress)
        self.data_export_worker.finished.connect(lambda: QMessageBox.information(self.main_window, "成功", f"数据已成功导出到:\n{filepath}"))
        self.data_export_worker.finished.connect(progress.accept)
        self.data_export_worker.error.connect(lambda msg: QMessageBox.critical(self.main_window, "导出失败", msg))
        self.data_export_worker.error.connect(progress.accept)
        
        self.data_export_worker.start()
        progress.exec()

    def _on_batch_export_summary_ready(self, summary_message: str):
        if self.batch_export_dialog and self.batch_export_dialog.isVisible():
             QMessageBox.information(self.main_window, "批量导出完成", summary_message)
        else:
             self.ui.status_bar.showMessage(summary_message, 10000)

    def _on_batch_export_thread_finished(self):
        logger.info("BatchExportWorker thread has finished. Cleaning up references.")
        self.batch_export_worker = None
        self.batch_export_dialog = None
    
    def on_main_window_close(self):
        if self.batch_export_worker and self.batch_export_worker.isRunning():
            if QMessageBox.question(self.main_window, "确认", "批量导出正在进行，确定退出吗？") == QMessageBox.StandardButton.Yes:
                self.batch_export_worker.cancel()
                try:
                    self.batch_export_worker.progress.disconnect()
                    self.batch_export_worker.log_message.disconnect()
                    self.batch_export_worker.summary_ready.disconnect()
                    self.batch_export_worker.finished.disconnect()
                except TypeError:
                    pass
                self.batch_export_worker.wait(30000)
                self.batch_export_worker.deleteLater()
                return True
            else:
                return False
        return True
```
--- END OF FILE export_handler.py ---

--- START OF FILE headless_renderer.py ---
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
无头渲染器，用于在非GUI线程中安全地生成Matplotlib图像。
"""
import numpy as np
import pandas as pd
import logging
import sys
from typing import Dict, Any, List

from matplotlib.figure import Figure
from matplotlib.backends.backend_agg import FigureCanvasAgg
import matplotlib.ticker as ticker
import matplotlib.font_manager as fm
import matplotlib.pyplot as plt

from src.core.rendering_core import prepare_gridded_data
from src.core.formula_engine import FormulaEngine
from src.core.constants import VectorPlotType, StreamlineColor

logger = logging.getLogger(__name__)

def _setup_headless_fonts():
    """为无头渲染器配置跨平台字体。"""
    font_name = None
    if sys.platform == "win32":
        font_name = "Microsoft YaHei"
    elif sys.platform == "darwin": # macOS
        font_name = "PingFang SC"
    else: # Linux
        font_name = "WenQuanYi Zen Hei"
    
    prop = fm.FontProperties(family=font_name)
    if fm.findfont(prop, fallback_to_default=False):
        plt.rcParams['font.sans-serif'] = [font_name]
    else:
        fallback_fonts = ['SimHei', 'Heiti TC', 'sans-serif']
        plt.rcParams['font.sans-serif'] = fallback_fonts
        logger.warning(f"无法找到 '{font_name}' 字体，将回退到 {fallback_fonts}。中文显示可能不正常。")
    
    plt.rcParams['axes.unicode_minus'] = False

class HeadlessPlotter:
    """
    一个纯粹的、非GUI的绘图类，用于在后台线程中生成图像。
    """
    def __init__(self, plot_config: Dict[str, Any]):
        self.config = plot_config
        self.formula_engine = FormulaEngine()
        self.grid_resolution = self.config.get('grid_resolution', (150, 150))
        self.formula_engine.update_custom_global_variables(self.config.get('global_scope', {}))
        _setup_headless_fonts()

    def render_frame(self, data: pd.DataFrame, all_vars: List[str]) -> np.ndarray:
        """
        接收单帧数据和配置，返回一个代表渲染图像的NumPy数组。
        """
        self.formula_engine.update_allowed_variables(all_vars)

        try:
            render_config = {
                'x_axis_formula': self.config.get('x_axis_formula') or 'x',
                'y_axis_formula': self.config.get('y_axis_formula') or 'y',
                'heatmap_config': self.config.get('heatmap_config', {}),
                'contour_config': self.config.get('contour_config', {}),
                'vector_config': self.config.get('vector_config', {}),
                'use_gpu': self.config.get('use_gpu', False),
                'grid_resolution': self.grid_resolution
            }
            interpolated_results = prepare_gridded_data(data, render_config, self.formula_engine)
        except Exception as e:
            logger.error(f"无头渲染器数据准备失败: {e}")
            raise

        gx = interpolated_results.get('grid_x')
        gy = interpolated_results.get('grid_y')
        if gx is None or gy is None:
            raise ValueError("网格坐标(gx, gy)未生成，无法绘图。")

        dpi = self.config.get('export_dpi', 300)
        fig = Figure(figsize=(12, 8), dpi=dpi, tight_layout=True)
        ax = fig.add_subplot(111)
        colorbar_obj = None
        
        heatmap_cfg = self.config.get('heatmap_config', {})
        contour_cfg = self.config.get('contour_config', {})
        vector_cfg = self.config.get('vector_config', {})

        heatmap_data = interpolated_results.get('heatmap_data')
        if heatmap_cfg.get('enabled') and heatmap_data is not None and not np.all(np.isnan(heatmap_data)):
            vmin_str, vmax_str = heatmap_cfg.get('vmin'), heatmap_cfg.get('vmax')
            vmin = float(vmin_str) if vmin_str is not None and str(vmin_str).strip() != '' else None
            vmax = float(vmax_str) if vmax_str is not None and str(vmax_str).strip() != '' else None
            
            valid_data = heatmap_data[~np.isnan(heatmap_data)]
            if valid_data.size > 0:
                if vmin is None: vmin = np.min(valid_data)
                if vmax is None: vmax = np.max(valid_data)

            pcm = ax.pcolormesh(gx, gy, heatmap_data, 
                                cmap=heatmap_cfg.get('colormap', 'viridis'), 
                                vmin=vmin, vmax=vmax, shading='gouraud')
            colorbar_obj = fig.colorbar(pcm, ax=ax, format=ticker.ScalarFormatter(useMathText=True))
            colorbar_obj.set_label(heatmap_cfg.get('formula', ''))

        contour_data = interpolated_results.get('contour_data')
        if contour_cfg.get('enabled') and contour_data is not None and not np.all(np.isnan(contour_data)):
            cont = ax.contour(gx, gy, contour_data, 
                               levels=contour_cfg.get('levels', 10), 
                               colors=contour_cfg.get('colors', 'black'), 
                               linewidths=contour_cfg.get('linewidths', 1.0))
            if contour_cfg.get('show_labels'):
                ax.clabel(cont, inline=True, fontsize=8, fmt='%.2e')
        
        vector_u_data, vector_v_data = interpolated_results.get('vector_u_data'), interpolated_results.get('vector_v_data')
        if vector_cfg.get('enabled') and vector_u_data is not None and vector_v_data is not None:
            plot_type = VectorPlotType.from_str(vector_cfg.get('type', 'Quiver'))
            if plot_type == VectorPlotType.QUIVER:
                opts = vector_cfg.get('quiver_options', {}); density = opts.get('density', 10); scale = opts.get('scale', 1.0)
                sl = slice(None, None, density)
                ax.quiver(gx[sl, sl], gy[sl, sl], vector_u_data[sl, sl], vector_v_data[sl, sl], 
                          scale=scale, scale_units='xy', angles='xy', color='black')
            elif plot_type == VectorPlotType.STREAMLINE:
                opts = vector_cfg.get('streamline_options', {})
                density = opts.get('density', 1.0)
                linewidth = opts.get('linewidth', 1.0)
                color_by = StreamlineColor.from_str(opts.get('color_by', StreamlineColor.MAGNITUDE.value))
                
                color_data = 'black'
                if color_by == StreamlineColor.MAGNITUDE: color_data = np.sqrt(vector_u_data**2 + vector_v_data**2)
                elif color_by == StreamlineColor.U_COMPONENT: color_data = vector_u_data
                elif color_by == StreamlineColor.V_COMPONENT: color_data = vector_v_data
                
                stream_plot = ax.streamplot(gx, gy, vector_u_data, vector_v_data, density=density, linewidth=linewidth, color=color_data, cmap='viridis' if isinstance(color_data, np.ndarray) else None)
                if isinstance(color_data, np.ndarray) and not colorbar_obj:
                    fig.colorbar(stream_plot.lines, ax=ax).set_label(f"流线 ({color_by.value})")

        ax.set_aspect('auto', adjustable='box'); ax.grid(True, linestyle='--', alpha=0.5)
        ax.set_xlabel(self.config.get('x_axis_formula') or 'x'); ax.set_ylabel(self.config.get('y_axis_formula') or 'y')
        
        title = self.config.get('chart_title', '')
        if not title:
             # Find frame_index and time from the data if possible, for default title
            frame_index = data['frame_index'].iloc[0] if 'frame_index' in data.columns and not data.empty else 'N/A'
            timestamp = data['timestamp'].iloc[0] if 'timestamp' in data.columns and not data.empty else 'N/A'
            try:
                title = f"Frame: {frame_index}, Time: {timestamp:.3f}s"
            except (TypeError, ValueError):
                title = f"Frame: {frame_index}, Time: {timestamp}"
        ax.set_title(title)

        formatter = ticker.ScalarFormatter(useMathText=True); formatter.set_scientific(True); formatter.set_powerlimits((-3, 3))
        ax.xaxis.set_major_formatter(formatter); ax.yaxis.set_major_formatter(formatter)

        x_min, x_max = np.nanmin(gx), np.nanmax(gx); y_min, y_max = np.nanmin(gy), np.nanmax(gy)
        xr = x_max - x_min or 1; yr = y_max - y_min or 1; m = 0.05
        ax.set_xlim(x_min - m * xr, x_max + m * xr); ax.set_ylim(y_min - m * yr, y_max + m * yr)

        canvas = FigureCanvasAgg(fig)
        canvas.draw()
        
        buf = canvas.buffer_rgba()
        image_array = np.asarray(buf)
        fig.clear()
        
        return image_array
```
--- END OF FILE headless_renderer.py ---

--- START OF FILE help_content.py ---
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
帮助文档内容模块
"""
from typing import List, Dict

def get_formula_help_html(base_variables: List[str], custom_global_variables: Dict[str, float], science_constants: Dict[str, float]) -> str:
    """生成公式帮助的HTML内容"""
    var_list_html = "".join([f"<li><code>{var}</code></li>" for var in sorted(list(base_variables))])
    const_list_html = "".join([f"<li><code>{key}</code>: {val:.4e}</li>" for key, val in science_constants.items()])
    
    all_globals = sorted(custom_global_variables.items())
    custom_globals_html = "".join([f"<li><code>{key}</code>: {val:.4e}</li>" for key, val in all_globals])

    global_section = ""
    if custom_globals_html:
        global_section += f"""
        <h3>全局变量与常量</h3>
        <p>这些是在“全局统计”标签页中自动计算或由用户定义的常量，它们在所有计算中可用:</p>
        <ul>{custom_globals_html}</ul>
        """

    return f"""
    <html><head><style>
        body {{ font-family: sans-serif; line-height: 1.6; }}
        h2 {{ color: #005A9C; border-bottom: 2px solid #005A9C; padding-bottom: 5px; }}
        h3 {{ color: #005A9C; border-bottom: 1px solid #ccc; padding-bottom: 5px; }}
        code {{ background-color: #f0f0f0; padding: 2px 5px; border: 1px solid #ddd; border-radius: 3px; font-family: monospace; }}
        ul {{ list-style-type: none; padding-left: 0; }} li {{ margin-bottom: 5px; }}
        .note {{ border-left: 3px solid #17a2b8; padding-left: 15px; background-color: #e2f3f5; margin-top:10px; }}
        .new {{ color: red; font-weight: bold; }}
    </style></head><body>
        <h2>公式语法说明</h2><p>您可以使用标准的Python数学表达式来创建新的派生变量或进行可视化。</p>
        
        <h3>可用变量与常量</h3>
        <h4>数据变量 (逐点变化)</h4>
        <p>以下变量来自您的数据，代表每个数据点的属性:</p>
        <ul>{var_list_html or "<li>(无可用数据)</li>"}</ul>
        {global_section or "<h4>全局变量与常量</h4><p>(请先在“全局统计”标签页中进行计算)</p>"}
        <h4>科学常量</h4><ul>{const_list_html}</ul>

        <h3>函数列表</h3>
        <h4>标准数学函数</h4>
        <ul>
            <li><b>基本运算符:</b> <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>**</code> (乘方), <code>()</code></li>
            <li><b>通用函数:</b> <code>sin</code>, <code>cos</code>, <code>sqrt</code>, <code>log</code>, <code>abs</code>, <code>min(a,b)</code>, <code>max(a,b)</code> 等。</li>
        </ul>

        <h4><span class="new">逐帧</span>聚合函数 (对当前帧所有点计算)</h4>
        <div class="note"><p>这些函数在“逐帧计算”或可视化公式中使用，对当前显示帧的数据进行聚合。</p></div>
        <ul>
            <li><code>mean(expr)</code>, <code>sum(expr)</code>, <code>std(expr)</code>, <code>var(expr)</code>, <code>median(expr)</code></li>
            <li><code>min_frame(expr)</code>, <code>max_frame(expr)</code> (为避免与`min/max`数学函数冲突)</li>
        </ul>

        <h4>空间运算/矩阵函数 (对网格化场计算)</h4>
        <div class="note">
            <p>这些函数对插值到网格上的<b>空间场</b>进行操作，用于计算导数等。它们可以<b>相互嵌套</b>。</p>
        </div>
        <ul>
            <li><code>grad_x(field)</code>: 计算标量场 <code>field</code> 的X方向梯度 (∂/dx)。</li>
            <li><code>grad_y(field)</code>: 计算标量场 <code>field</code> 的Y方向梯度 (∂/dy)。</li>
            <li><code>div(u_field, v_field)</code>: 计算矢量场 <code>(u, v)</code> 的散度 (∂u/∂x + ∂v/∂y)。</li>
            <li><code>curl(u_field, v_field)</code>: 计算2D矢量场 <code>(u, v)</code> 的旋度 (∂v/∂x - ∂u/∂y)，结果为标量。</li>
            <li><code>laplacian(field)</code>: 计算标量场 <code>field</code> 的拉普拉斯算子 (∂²/∂x² + ∂²/∂y²)。</li>
        </ul>

        <h3>示例</h3>
        <ul>
            <li><b>速度大小 (热力图):</b> <code>sqrt(u**2 + v**2)</code></li>
            <li><b>动压 (等高线):</b> <code>0.5 * rho * (u**2 + v**2)</code></li>
            <li><b>压力波动 (帧内):</b> <code>p - mean(p)</code></li>
            <li><b>速度脉动 (矢量图U分量):</b> <code>u - u_global_mean</code></li>
            <li><b>涡量 (热力图):</b> <code>curl(u, v)</code></li>
            <li><b>压力梯度X分量 (热力图):</b> <code>grad_x(p)</code></li>
            <li><b>嵌套示例 (复杂):</b> <code>grad_x(curl(rho*u, rho*v))</code></li>
        </ul>
    </body></html>"""

def get_custom_stats_help_html() -> str:
    """生成自定义全局统计帮助的HTML内容"""
    return """
    <html><head><style>
        body { font-family: sans-serif; line-height: 1.6; }
        h2 { color: #005A9C; border-bottom: 2px solid #005A9C; padding-bottom: 5px; }
        h3 { color: #005A9C; border-bottom: 1px solid #ccc; padding-bottom: 5px; }
        code { background-color: #f0f0f0; padding: 2px 5px; border: 1px solid #ddd; border-radius: 3px; font-family: monospace; }
        ul { list-style-type: circle; padding-left: 20px; }
        .note { border-left: 3px solid #f0ad4e; padding-left: 15px; background-color: #fcf8e3; margin-top:10px; }
        .new { color: red; font-weight: bold; }
    </style></head><body>
        <h2>自定义常量计算指南</h2>
        <p>此功能允许您基于<b>整个数据集</b>计算新的<b>全局常量</b>。这些定义会<span class="new">永久保存在数据库中</span>，并可在所有可视化公式中使用。</p>

        <h3>基本格式</h3>
        <p>每行定义一个常量: <code>new_constant_name = aggregate_function(expression)</code></p>

        <h3>计算模式</h3>
        <p>引擎会自动选择最高效的计算路径：</p>
        <ul>
            <li><b>标准公式 (无空间运算):</b> 使用<b>超快SQL查询</b>在数据库中直接完成。</li>
            <li><b>含空间运算的公式 (如 <code>curl</code>, <code>grad_x</code>等):</b> 自动切换到<span class="new">并行的逐帧迭代</span>模式。这会充分利用您的CPU多核性能，但仍可能需要一些时间。</li>
        </ul>

        <h3>组件说明</h3>
        <ul>
            <li><b><code>new_constant_name</code></b>: 新常量的名称 (字母、数字、下划线)。</li>
            <li><b><code>aggregate_function</code></b>: 聚合函数，对所有帧或所有点生效。支持 <code>mean</code>, <code>sum</code>, <code>std</code>, <code>var</code>。</li>
            <li><b><code>expression</code></b>: 数学表达式，支持:
                <ul>
                    <li>原始数据变量 (如 <code>u</code>, <code>p</code>)。</li>
                    <li>任何已计算的全局常量 (包括之前定义的)。</li>
                    <li>标准数学函数 (<code>sqrt</code>, <code>sin</code>等)。</li>
                    <li>新增的空间函数 (<code>grad_x</code>, <code>div</code>, <code>curl</code> 等)。</li>
                </ul>
            </li>
        </ul>

        <h3>工作流程</h3>
        <ol>
            <li>在文本框中添加或编辑您的定义。</li>
            <li>点击“<b>保存定义并重新计算</b>”按钮。</li>
            <li>您的定义会被保存到数据库，然后程序会开始计算。</li>
            <li>计算完成后，新的常量即可在任何地方使用。</li>
        </ol>

        <h3>示例</h3>
        <h4>1. 计算平均湍动能 (TKE) - <span style="color:green;">快速SQL模式</span></h4>
        <code>tke_global_mean = mean(0.5 * (u**2 + v**2))</code>

        <h4>2. 计算雷诺应力 - <span style="color:green;">快速SQL模式</span></h4>
        <code>reynolds_stress_uv = mean((u - u_global_mean) * (v - v_global_mean))</code>

        <h4>3. <span class="new">计算全场平均涡量 - 并行迭代模式</span></h4>
        <div class="note">
            <p>因为包含 <code>curl()</code>，此计算会并行地遍历所有帧，对每一帧计算涡量场，然后取所有帧涡量均值的均值。</p>
        </div>
        <code>mean_vorticity = mean(curl(u, v))</code>
    </body></html>
    """

def get_axis_title_help_html() -> str:
    return """
    <html><head><style>
        body { font-family: sans-serif; line-height: 1.6; }
        h2 { color: #005A9C; border-bottom: 2px solid #005A9C; padding-bottom: 5px; }
        code { background-color: #f0f0f0; padding: 2px 5px; border: 1px solid #ddd; border-radius: 3px; font-family: monospace; }
        ul { list-style-type: disc; padding-left: 20px; }
        .note {{ border-left: 3px solid #17a2b8; padding-left: 15px; background-color: #e2f3f5; margin-top:10px; }}
    </style></head><body>
        <h2>坐标轴与标题指南</h2>
        <ul>
            <li><b>X轴与Y轴公式:</b> 定义数据点在图表上的坐标。可使用任何数据变量和全局常量，如 <code>x</code>, <code>rho*u</code>, <code>x-x_global_mean</code>。</li>
            <li><b>图表标题:</b>
                <p>可以是静态文本，或使用 <code>{...}</code> 占位符语法包含动态信息。</p>
                <div class="note">
                    <p><b>注意:</b> 请不要使用Python的f-string (即不要在字符串前加'f')，直接使用大括号即可。</p>
                </div>
                <p>可用占位符:</p>
                <ul>
                    <li><code>{frame_index}</code> - 当前帧的索引。</li>
                    <li><code>{time}</code> - 当前帧的时间戳。您可以进行格式化，例如 <code>{time:.3f}</code> 会将时间戳显示为三位小数。</li>
                </ul>
                <p><b>示例:</b> <code>Frame: {frame_index}, Time: {time:.4f}s</code></p>
            </li>
        </ul>
    </body></html>
    """

def get_analysis_help_html() -> str:
    """生成“分析”选项卡功能的帮助HTML内容"""
    return """
    <html><head><style>
        body { font-family: sans-serif; line-height: 1.6; }
        h2 { color: #005A9C; border-bottom: 2px solid #005A9C; padding-bottom: 5px; }
        h3 { color: #28a745; border-bottom: 1px solid #ccc; padding-bottom: 5px; }
        code { background-color: #f0f0f0; padding: 2px 5px; border: 1px solid #ddd; border-radius: 3px; font-family: monospace; }
        ul { list-style-type: circle; padding-left: 20px; }
        .note { border-left: 3px solid #ffc107; padding-left: 15px; background-color: #fff9e2; margin-top:10px; }
        .new { color: #007bff; font-weight: bold; }
    </style></head><body>
        <h2>分析与数据管理指南</h2>
        <p>本页包含“分析”、“数据管理”和“可视化”中高级功能的说明。</p>

        <h3><span class="new">全局数据过滤器</span> (位于“数据管理”选项卡)</h3>
        <p>此功能允许您对<b>整个数据集</b>应用一个筛选条件，所有后续的可视化、统计计算和导出都将只考虑满足条件的数据点。</p>
        <ul>
            <li><b>语法:</b> 使用标准的 <b>SQL `WHERE` 子句</b> 语法 (不需要写 "WHERE" 关键字)。</li>
            <li><b>变量:</b> 您可以使用数据库中的任何原始或派生变量名。</li>
            <li><b>示例:</b>
                <ul>
                    <li><code>p > 101325</code> (只分析压力高于一个大气压的区域)</li>
                    <li><code>sqrt(u*u + v*v) > 100</code> (只分析高速区域)</li>
                    <li><code>x < 0.5 AND y > 0.2</code> (只分析某个几何区域)</li>
                </ul>
            </li>
        </ul>
        <div class="note">
            <p><b>重要:</b> 应用或更改过滤器后，建议点击主工具栏的“重置视图”按钮，以确保您看到的是过滤后数据的完整视图。</p>
        </div>

        <h3><span class="new">时间分析</span> (位于“可视化”选项卡)</h3>
        <p>此功能允许您在两种模式间切换：</p>
        <ul>
            <li><b>瞬时场:</b> 默认模式，显示单个时间步（帧）的数据。</li>
            <li><b>时间平均场:</b> 计算并显示一个指定时间范围（从起始帧到结束帧）内所有数据点的<b>平均值</b>。这对于观察稳态特征、消除瞬时波动非常有用。</li>
        </ul>

        <h2 style="margin-top:20px;">交互式分析工具</h2>

        <h3>数据探针</h3>
        <p>当您在图表上移动鼠标时，“数据探针”窗口会实时显示两种信息：</p>
        <ul>
            <li><b>最近原始数据点:</b> 离您鼠标最近的原始数据文件中那个点的值。</li>
            <li><b>鼠标位置插值数据:</b> 根据周围数据点插值计算出的、您鼠标精确位置上的值。这对于查看平滑的热力图和等高线图的精确数值非常有用。</li>
        </ul>

        <h3>一维剖面图</h3>
        <p>此功能允许您在2D图上画一条线，并查看变量如何沿着这条线变化。</p>
        <ol>
            <li>点击“<b>绘制剖面图</b>”按钮，鼠标将变为十字形。</li>
            <li>在图表上<b>第一次点击</b>，定义剖面线的<b>起点</b>。</li>
            <li>移动鼠标，您会看到一条预览线。<b>第二次点击</b>，定义剖面线的<b>终点</b>。</li>
            <li>一个新窗口会弹出，显示主热力图变量沿着这条线的数值分布图。</li>
        </ol>

        <h3>时间序列分析</h3>
        <p>此功能用于查看图上某一个固定点，其物理量随时间的变化情况。</p>
        <ol>
            <li>点击“<b>拾取时间序列点</b>”按钮，或点击“<b>按坐标拾取...</b>”按钮并输入精确坐标。</li>
            <li>一个新窗口会弹出。您可以在此窗口的下拉菜单中选择不同的变量，查看它们在该点的时间序列图。</li>
            <li>点击“<b>计算FFT</b>”按钮，可以对当前的时间序列进行快速傅里叶变换，分析其频域特性。</li>
        </ol>
    </body></html>
    """
```
--- END OF FILE help_content.py ---

--- START OF FILE main.py ---
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
InterVis
主程序入口
"""

import sys
import os
from PyQt6.QtWidgets import QApplication, QMessageBox

# 确保导入路径正确
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from src.main_window import MainWindow
from src.utils.logger import setup_logger

def main():
    """主函数"""
    logger = setup_logger()
    
    try:
        app = QApplication(sys.argv)
        app.setApplicationName("InterVis")
        app.setApplicationVersion("3.3-ProFinal") # 版本号更新
        app.setOrganizationName("StarsWhere")
        
        main_window = MainWindow()
        main_window.show()
        
        logger.info("InterVis v3.3-ProFinal 启动成功")
        sys.exit(app.exec())
        
    except Exception as e:
        logger.error(f"程序启动失败: {str(e)}", exc_info=True)
        msg_box = QMessageBox()
        msg_box.setIcon(QMessageBox.Icon.Critical)
        msg_box.setWindowTitle("启动错误")
        msg_box.setText(f"程序启动失败，请查看日志获取详细信息。\n\n错误: {str(e)}")
        msg_box.exec()
        sys.exit(1)

if __name__ == "__main__":
    main()
```
--- END OF FILE main.py ---

--- START OF FILE main_window.py ---
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import os
import logging
from typing import Optional
import numpy as np
from PyQt6.QtWidgets import QMainWindow, QMessageBox, QFileDialog, QLineEdit, QMenu, QInputDialog
from PyQt6.QtCore import Qt, QSettings, QPoint, QTimer

from src.core.data_manager import DataManager
from src.core.formula_engine import FormulaEngine
from src.core.constants import PickerMode
from src.utils.help_dialog import HelpDialog
from src.utils.gpu_utils import is_gpu_available
from src.utils.help_content import get_formula_help_html, get_axis_title_help_html, get_custom_stats_help_html, get_analysis_help_html
from src.ui.ui_setup import UiMainWindow
from src.ui.dialogs import ImportDialog, StatsProgressDialog
from src.ui.timeseries_dialog import TimeSeriesDialog
from src.ui.profile_plot_dialog import ProfilePlotDialog
from src.core.workers import DatabaseImportWorker

from src.handlers.config_handler import ConfigHandler
from src.handlers.stats_handler import StatsHandler
from src.handlers.export_handler import ExportHandler
from src.handlers.playback_handler import PlaybackHandler
from src.handlers.compute_handler import ComputeHandler

try:
    import moviepy.editor
    MOVIEPY_AVAILABLE = True
except ImportError:
    MOVIEPY_AVAILABLE = False

try:
    import imageio
    IMAGEIO_AVAILABLE = True
except ImportError:
    IMAGEIO_AVAILABLE = False

VIDEO_EXPORT_AVAILABLE = MOVIEPY_AVAILABLE or IMAGEIO_AVAILABLE
logger = logging.getLogger(__name__)

class MainWindow(QMainWindow):
    """应用程序的主窗口类。"""
    
    def __init__(self):
        super().__init__()
        
        self.settings = QSettings("StarsWhere", "InterVis")
        self.data_manager = DataManager()
        self.formula_engine = FormulaEngine()
        self.ui = UiMainWindow()

        self.current_frame_index: int = 0
        self._should_reset_view_after_refresh: bool = False
        
        self.project_dir = self.settings.value("project_directory", os.path.join(os.getcwd(), "data"))
        self.output_dir = self.settings.value("output_directory", os.path.join(os.getcwd(), "output"))
        os.makedirs(self.project_dir, exist_ok=True)
        os.makedirs(self.output_dir, exist_ok=True)
        
        self.redraw_debounce_timer = QTimer(self); self.redraw_debounce_timer.setSingleShot(True); self.redraw_debounce_timer.setInterval(150)
        self.validation_timer = QTimer(self); self.validation_timer.setSingleShot(True); self.validation_timer.setInterval(500)

        self.import_worker: Optional[DatabaseImportWorker] = None
        self.import_progress_dialog: Optional[ImportDialog] = None
        self.timeseries_dialog: Optional[TimeSeriesDialog] = None
        self.profile_dialog: Optional[ProfilePlotDialog] = None

        self.config_handler = ConfigHandler(self, self.ui)
        self.stats_handler = StatsHandler(self, self.ui, self.data_manager, self.formula_engine)
        self.export_handler = ExportHandler(self, self.ui, self.data_manager, self.config_handler)
        self.playback_handler = PlaybackHandler(self, self.ui, self.data_manager)
        self.compute_handler = ComputeHandler(self, self.ui, self.data_manager, self.formula_engine)
        
        self._init_ui()
        self._connect_signals()
        self._load_settings()
        self._initialize_project()

    def _init_ui(self):
        self.ui.setup_ui(self, self.formula_engine)
        self.ui.gpu_checkbox.setEnabled(is_gpu_available())
        self.ui.data_dir_line_edit.setText(self.project_dir)
        self.export_handler.set_output_dir(self.output_dir)
        
        if not VIDEO_EXPORT_AVAILABLE:
            tooltip = "功能不可用：请安装 moviepy 或 imageio"
            self.ui.export_vid_btn.setEnabled(False); self.ui.export_vid_btn.setToolTip(tooltip)
            self.ui.batch_export_btn.setEnabled(False); self.ui.batch_export_btn.setToolTip(tooltip)

        self._update_gpu_status_label()
        self._on_vector_plot_type_changed()
        self._on_time_analysis_mode_changed()

    def _connect_signals(self):
        self.data_manager.error_occurred.connect(self._on_error)
        self.redraw_debounce_timer.timeout.connect(self._apply_visualization_settings)
        self.validation_timer.timeout.connect(self._validate_all_formulas)
        
        # Plot Widget
        self.ui.plot_widget.mouse_moved.connect(self._on_mouse_moved)
        self.ui.plot_widget.probe_data_ready.connect(self._on_probe_data)
        self.ui.plot_widget.value_picked.connect(self._on_value_picked)
        self.ui.plot_widget.timeseries_point_picked.connect(self._on_timeseries_point_picked)
        self.ui.plot_widget.profile_line_defined.connect(self._on_profile_line_defined)
        self.ui.plot_widget.plot_rendered.connect(self._on_plot_rendered)
        self.ui.plot_widget.interpolation_error.connect(self._on_interpolation_error)
        
        # Menu & Toolbar
        self.ui.open_data_dir_action.triggered.connect(self._change_project_directory)
        self.ui.reload_action.triggered.connect(self._force_reload_data)
        self.ui.exit_action.triggered.connect(self.close)
        self.ui.reset_view_action.triggered.connect(self.ui.plot_widget.reset_view)
        self.ui.toggle_panel_action.triggered.connect(self._toggle_control_panel)
        self.ui.full_screen_action.triggered.connect(self._toggle_full_screen)
        self.ui.formula_help_action.triggered.connect(lambda: self._show_help("formula"))
        self.ui.analysis_help_action.triggered.connect(lambda: self._show_help("analysis"))
        self.ui.about_action.triggered.connect(self._show_about)

        # General Controls
        self.ui.change_data_dir_btn.clicked.connect(self._change_project_directory)
        self.ui.refresh_button.clicked.connect(lambda: self._force_refresh_plot(reset_view=True))
        self.ui.apply_cache_btn.clicked.connect(self._apply_cache_settings)
        self.ui.gpu_checkbox.toggled.connect(self._on_gpu_toggle)
        self.ui.vector_plot_type.currentIndexChanged.connect(self._on_vector_plot_type_changed)
        
        # Analysis/Data Management Controls
        self.ui.apply_filter_btn.clicked.connect(self._apply_global_filter)
        self.ui.time_analysis_mode_combo.currentIndexChanged.connect(self._on_time_analysis_mode_changed)
        self.ui.pick_timeseries_btn.toggled.connect(self._on_pick_timeseries_toggled)
        self.ui.pick_by_coords_btn.clicked.connect(self._pick_timeseries_by_coords)
        self.ui.draw_profile_btn.toggled.connect(self._on_draw_profile_toggled)
        self.ui.draw_profile_by_coords_btn.clicked.connect(self._draw_profile_by_coords)
        self.ui.analysis_help_btn.clicked.connect(lambda: self._show_help("analysis"))
        self.ui.time_analysis_help_btn.clicked.connect(lambda: self._show_help("analysis"))
        self.ui.time_avg_start_slider.valueChanged.connect(self.ui.time_avg_start_spinbox.setValue)
        self.ui.time_avg_start_spinbox.valueChanged.connect(self.ui.time_avg_start_slider.setValue)
        self.ui.time_avg_end_slider.valueChanged.connect(self.ui.time_avg_end_spinbox.setValue)
        self.ui.time_avg_end_spinbox.valueChanged.connect(self.ui.time_avg_end_slider.setValue)
        self.ui.time_avg_start_spinbox.editingFinished.connect(self._trigger_auto_apply)
        self.ui.time_avg_end_spinbox.editingFinished.connect(self._trigger_auto_apply)

        # Connect all handlers
        self.config_handler.connect_signals()
        self.stats_handler.connect_signals()
        self.export_handler.connect_signals()
        self.playback_handler.connect_signals()
        self.compute_handler.connect_signals()
        
        self._connect_auto_apply_widgets()

    def _get_all_formula_editors(self) -> list[QLineEdit]:
        """Returns a list of all QLineEdit widgets used for formulas."""
        return [
            self.ui.x_axis_formula, self.ui.y_axis_formula, self.ui.chart_title_edit,
            self.ui.heatmap_formula, self.ui.contour_formula,
            self.ui.vector_u_formula, self.ui.vector_v_formula,
            self.ui.new_variable_formula_edit, self.ui.filter_text_edit
        ]

    def _connect_auto_apply_widgets(self):
        """Connects widgets that should trigger an automatic plot refresh."""
        widgets = [
            self.ui.heatmap_enabled, self.ui.heatmap_colormap, 
            self.ui.contour_enabled, self.ui.contour_labels, self.ui.contour_levels, 
            self.ui.contour_linewidth, self.ui.contour_colors, self.ui.vector_enabled, 
            self.ui.vector_plot_type, self.ui.quiver_density_spinbox, self.ui.quiver_scale_spinbox, 
            self.ui.stream_density_spinbox, self.ui.stream_linewidth_spinbox, self.ui.stream_color_combo, 
            self.ui.filter_enabled_checkbox
        ]
        
        for editor in self._get_all_formula_editors():
            editor.textChanged.connect(self.validation_timer.start)
            editor.editingFinished.connect(self._trigger_auto_apply)

        for w in widgets:
            if hasattr(w, 'toggled'): w.toggled.connect(self._trigger_auto_apply)
            elif hasattr(w, 'currentIndexChanged'): w.currentIndexChanged.connect(self._trigger_auto_apply)
            elif hasattr(w, 'valueChanged'): w.valueChanged.connect(self._trigger_auto_apply)
    
    def _trigger_auto_apply(self, *args):
        if self.config_handler._is_loading_config: return
        self.config_handler.mark_config_as_dirty()
        if self.data_manager.get_frame_count() > 0:
            self._should_reset_view_after_refresh = False
            self.redraw_debounce_timer.start()

    def _validate_all_formulas(self):
        """Validate syntax of all formula input fields and update their styles."""
        for editor in self._get_all_formula_editors():
            is_valid, error_msg = self.formula_engine.validate_syntax(editor.text())
            if is_valid:
                editor.setStyleSheet("")
                editor.setToolTip("")
            else:
                editor.setStyleSheet("background-color: #ffe0e0;") # Light red
                editor.setToolTip(error_msg)

    def _initialize_project(self):
        if not self.data_manager.setup_project_directory(self.project_dir): return
        if self.data_manager.is_database_ready():
            logger.info(f"在 {self.project_dir} 中找到现有数据库，直接加载。")
            self._load_project_data()
        else:
            reply = QMessageBox.question(self, "未找到数据库", f"在目录 '{self.project_dir}' 中未找到数据库文件。\n\n是否从此目录中的所有CSV文件创建新的数据库？", QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
            if reply == QMessageBox.StandardButton.Yes: self._start_database_import()
            else: self.ui.status_bar.showMessage("操作已取消。请选择一个包含CSV文件或数据库的项目目录。", 5000)

    def _start_database_import(self):
        self.import_progress_dialog = ImportDialog(self, "正在创建和分析数据库...")
        self.import_worker = DatabaseImportWorker(self.data_manager)
        self.import_worker.progress.connect(self.import_progress_dialog.update_progress)
        self.import_worker.log_message.connect(self.import_progress_dialog.set_log_message)
        self.import_worker.finished.connect(self._on_import_finished)
        self.import_worker.error.connect(self._on_error)
        self.import_worker.start()
        self.import_progress_dialog.exec()
        
    def _on_import_finished(self):
        if self.import_progress_dialog: self.import_progress_dialog.accept()
        QMessageBox.information(self, "导入完成", "数据库已成功创建，基础统计数据已计算完毕。")
        self._load_project_data()

    def _load_project_data(self):
        self.data_manager.post_import_setup()
        self._update_db_info()
        frame_count = self.data_manager.get_frame_count()
        if frame_count > 0:
            self.stats_handler.load_definitions_and_stats()
            self.formula_engine.update_allowed_variables(self.data_manager.get_variables())
            self.ui.time_slider.setMaximum(frame_count - 1)
            self.ui.video_start_frame.setMaximum(frame_count - 1); self.ui.video_end_frame.setMaximum(frame_count - 1); self.ui.video_end_frame.setValue(frame_count - 1)
            for w in [self.ui.time_avg_start_slider, self.ui.time_avg_start_spinbox, self.ui.time_avg_end_slider, self.ui.time_avg_end_spinbox]: w.setMaximum(frame_count - 1)
            self.ui.time_avg_end_spinbox.setValue(frame_count - 1)
            self.config_handler.populate_config_combobox()
            self.ui.compute_and_add_btn.setEnabled(True)
            self._force_refresh_plot(reset_view=True)
            self.ui.status_bar.showMessage(f"项目加载成功，共 {frame_count} 帧数据。", 5000)
        else:
            self.ui.status_bar.showMessage("项目加载失败：数据库为空或无法读取。", 5000); QMessageBox.warning(self, "数据为空", "项目加载失败：数据库为空或无法读取。")
            self.ui.compute_and_add_btn.setEnabled(False)
    
    def _update_db_info(self):
        """Updates the database info label in the UI."""
        info = self.data_manager.get_database_info()
        db_path = info.get("db_path", "N/A")
        is_ready = info.get("is_ready", False)
        frame_count = info.get("frame_count", 0)
        variables = info.get("variables", [])

        db_size_mb = 0
        if db_path != "N/A" and os.path.exists(db_path):
            db_size_mb = os.path.getsize(db_path) / (1024 * 1024)

        db_info_text = f"路径: {os.path.basename(db_path)} | 帧: {frame_count} | 变量: {len(variables)} | 大小: {db_size_mb:.2f} MB"
        self.ui.db_info_label.setText(db_info_text)
        self.ui.db_info_label.setToolTip(db_path)

    def _apply_global_filter(self):
        try:
            filter_text = self.ui.filter_text_edit.text() if self.ui.filter_enabled_checkbox.isChecked() else ""
            self.data_manager.set_global_filter(filter_text)
            self._force_refresh_plot(reset_view=True)
            self.ui.status_bar.showMessage("全局过滤器已应用。", 3000)
        except ValueError as e:
            QMessageBox.critical(self, "过滤器错误", f"过滤器语法无效: {e}")

    def _on_time_analysis_mode_changed(self):
        is_time_avg = self.ui.time_analysis_mode_combo.currentText() == "时间平均场"
        self.ui.playback_widget.setVisible(not is_time_avg)
        self.playback_handler.set_enabled(not is_time_avg)
        self.ui.time_average_range_widget.setVisible(is_time_avg)
        self._trigger_auto_apply()
        
    def _on_pick_timeseries_toggled(self, checked):
        if checked:
            self.ui.draw_profile_btn.setChecked(False)
            self.ui.plot_widget.set_picker_mode(PickerMode.TIMESERIES)
            self.ui.status_bar.showMessage("时间序列模式: 在图表上单击一点以拾取 (右键取消)。", 0)
        elif self.ui.plot_widget.picker_mode == PickerMode.TIMESERIES:
            self.ui.plot_widget.set_picker_mode(None)
            self.ui.status_bar.clearMessage()

    def _on_draw_profile_toggled(self, checked):
        if checked:
            self.ui.pick_timeseries_btn.setChecked(False)
            self.ui.plot_widget.set_picker_mode(PickerMode.PROFILE_START)
            self.ui.status_bar.showMessage("剖面图模式: 点击定义剖面线起点 (右键取消)。", 0)
        elif self.ui.plot_widget.picker_mode in [PickerMode.PROFILE_START, PickerMode.PROFILE_END]:
            self.ui.plot_widget.set_picker_mode(None)
            self.ui.status_bar.clearMessage()

    def _pick_timeseries_by_coords(self):
        text, ok = QInputDialog.getText(self, "按坐标拾取时间序列点", "请输入坐标 (x, y):", QLineEdit.EchoMode.Normal, "0.0, 0.0")
        if ok and text:
            try:
                x_str, y_str = text.split(',')
                coords = (float(x_str.strip()), float(y_str.strip()))
                self._on_timeseries_point_picked(coords)
            except (ValueError, IndexError):
                QMessageBox.warning(self, "输入无效", "请输入格式为 'x, y' 的两个数值。")

    def _draw_profile_by_coords(self):
        start_text, ok1 = QInputDialog.getText(self, "绘制剖面图", "请输入起点坐标 (x1, y1):")
        if not (ok1 and start_text): return

        end_text, ok2 = QInputDialog.getText(self, "绘制剖面图", "请输入终点坐标 (x2, y2):")
        if not (ok2 and end_text): return
        
        try:
            x1_str, y1_str = start_text.split(',')
            start_coords = (float(x1_str.strip()), float(y1_str.strip()))
            
            x2_str, y2_str = end_text.split(',')
            end_coords = (float(x2_str.strip()), float(y2_str.strip()))
            
            self._on_profile_line_defined(start_coords, end_coords)
        except (ValueError, IndexError):
            QMessageBox.warning(self, "输入无效", "请输入格式为 'x, y' 的两个数值。")

    def _on_timeseries_point_picked(self, coords):
        self.ui.pick_timeseries_btn.setChecked(False)
        if self.timeseries_dialog and self.timeseries_dialog.isVisible(): self.timeseries_dialog.close()
        
        filter_clause = self.data_manager.global_filter_clause if self.ui.filter_enabled_checkbox.isChecked() else ""
        self.timeseries_dialog = TimeSeriesDialog(coords, self.data_manager, filter_clause, self)
        self.timeseries_dialog.show()

    def _on_profile_line_defined(self, start_point, end_point):
        self.ui.draw_profile_btn.setChecked(False)
        if not self.ui.plot_widget.interpolated_results:
            QMessageBox.warning(self, "无数据", "无可用于剖面的插值数据。"); return
        if self.profile_dialog and self.profile_dialog.isVisible(): self.profile_dialog.close()
        
        available_data = {
            key.replace('_data', ''): self.config_handler.get_current_config().get(key.replace('_data',''),{}).get('formula', key.replace('_data',''))
            for key, data in self.ui.plot_widget.interpolated_results.items() 
            if 'data' in key and isinstance(data, np.ndarray)
        }

        self.profile_dialog = ProfilePlotDialog(
            start_point, end_point, self.ui.plot_widget.interpolated_results,
            available_data, self.output_dir, self
        )
        self.profile_dialog.show()

    def _apply_visualization_settings(self):
        if self.data_manager.get_frame_count() == 0: return
        
        config = self.config_handler.get_current_config()
        
        self.ui.plot_widget.set_config(
            heatmap_config=config['heatmap'], contour_config=config['contour'],
            vector_config=config['vector'], analysis=config['analysis'],
            x_axis_formula=config['axes']['x_formula'], y_axis_formula=config['axes']['y_formula'],
            chart_title=config['axes']['title'],
            grid_resolution=(config['export']['video_grid_w'], config['export']['video_grid_h']),
            use_gpu=config['performance']['gpu']
        )
        
        is_time_avg = config['analysis']['time_average']['enabled']
        if is_time_avg:
            start, end = config['analysis']['time_average']['start_frame'], config['analysis']['time_average']['end_frame']
            if start >= end: self.ui.status_bar.showMessage("时间平均范围无效：起始帧必须小于结束帧。", 3000); return
            data = self.data_manager.get_time_averaged_data(start, end)
            self.ui.plot_widget.update_data(data)
            self._update_frame_info(is_time_avg=True, start=start, end=end)
        else:
            self._load_frame(self.current_frame_index)
            
        self.ui.status_bar.showMessage("可视化设置已更新。", 2000)

    def _load_frame(self, frame_index: int):
        if not (0 <= frame_index < self.data_manager.get_frame_count()): return
        data = self.data_manager.get_frame_data(frame_index)
        if data is not None:
            self.current_frame_index = frame_index
            self.ui.plot_widget.update_data(data)
            self._update_frame_info()
            if self.ui.plot_widget.last_mouse_coords: self.ui.plot_widget.get_probe_data_at_coords(*self.ui.plot_widget.last_mouse_coords)

    def _update_frame_info(self, is_time_avg: bool = False, start: int = 0, end: int = 0):
        if is_time_avg:
            self.ui.frame_info_label.setText(f"时间平均: 帧 {start}-{end}")
            self.ui.timestamp_label.setText("")
        else:
            fc = self.data_manager.get_frame_count()
            self.ui.frame_info_label.setText(f"帧: {self.current_frame_index + 1}/{fc if fc > 0 else '?'}")
            info = self.data_manager.get_frame_info(self.current_frame_index)
            if info and 'timestamp' in info: self.ui.timestamp_label.setText(f"时间戳: {info.get('timestamp', 'N/A')}")
        
        self.ui.cache_label.setText(f"缓存: {self.data_manager.get_cache_info()['size']}/{self.data_manager.get_cache_info()['max_size']}")

    def _on_error(self, message: str):
        if self.import_progress_dialog and self.import_progress_dialog.isVisible(): self.import_progress_dialog.accept()
        self.ui.status_bar.showMessage(f"错误: {message}", 5000)
        QMessageBox.critical(self, "发生错误", message)

    def _on_mouse_moved(self, x, y): self.ui.probe_coord_label.setText(f"({x:.3e}, {y:.3e})")
    
    def _on_probe_data(self, data):
        lines = []
        if data.get('variables'): 
            lines.extend([f"{'--- 最近原始数据点 ---':^40}"] + [f"{k:<18s} {v:12.6e}" for k, v in data['variables'].items()] + [""])
        
        if data.get('interpolated'):
            config = self.config_handler.get_current_config()
            lines.append(f"{'--- 鼠标位置插值数据 ---':^40}")
            
            probe_map = {
                'heatmap': f"热力图 ({config['heatmap'].get('formula', 'N/A')})",
                'contour': f"等高线 ({config['contour'].get('formula', 'N/A')})",
                'vector_u': f"U分量 ({config['vector'].get('u_formula', 'N/A')})",
                'vector_v': f"V分量 ({config['vector'].get('v_formula', 'N/A')})",
            }
            
            for key, value in data['interpolated'].items():
                display_name = probe_map.get(key, key)
                val_str = f"{value:12.6e}" if isinstance(value, (int,float)) and not np.isnan(value) else 'N/A'
                lines.append(f"{display_name:<25s} {val_str}")
        
        self.ui.probe_text.setPlainText("\n".join(lines))


    def _on_value_picked(self, mode, value):
        target = self.ui.heatmap_vmin if mode == PickerMode.VMIN else self.ui.heatmap_vmax
        target.setText(f"{value:.4e}"); self._trigger_auto_apply()

    def _on_plot_rendered(self):
        if self.playback_handler.is_playing: self.playback_handler.play_timer.start()
        if self._should_reset_view_after_refresh: self.ui.plot_widget.reset_view(); self._should_reset_view_after_refresh = False
        
        if self.ui.plot_widget.picker_mode == PickerMode.PROFILE_END:
            self.ui.status_bar.showMessage("剖面图模式: 点击定义剖面线终点 (右键取消)。", 0)

    def _on_interpolation_error(self, message: str):
        QMessageBox.critical(self, "可视化错误", f"无法渲染图形，公式可能存在问题。\n\n错误详情:\n{message}")
        self.ui.status_bar.showMessage(f"渲染错误: {message}", 5000)

    def _on_gpu_toggle(self, is_on): self.ui.plot_widget.set_config(use_gpu=is_on); self._update_gpu_status_label(); self._trigger_auto_apply()
    def _on_vector_plot_type_changed(self):
        is_q = self.ui.vector_plot_type.currentData(Qt.ItemDataRole.UserRole) == self.config_handler.VectorPlotType.QUIVER
        self.ui.quiver_options_group.setVisible(is_q); self.ui.streamline_options_group.setVisible(not is_q); self._trigger_auto_apply()

    def _force_refresh_plot(self, reset_view=False): self._should_reset_view_after_refresh = reset_view; self._apply_visualization_settings()
    
    def _show_help(self, help_type: str):
        content = ""
        if help_type == "formula": content = get_formula_help_html( self.data_manager.get_variables(), self.formula_engine.custom_global_variables, self.formula_engine.science_constants )
        elif help_type == "axis_title": content = get_axis_title_help_html()
        elif help_type == "custom_stats": content = get_custom_stats_help_html()
        elif help_type == "analysis": content = get_analysis_help_html()
        if content: HelpDialog(content, self).exec()

    def _show_about(self): QMessageBox.about(self, "关于 InterVis", "<h2>InterVis v3.3-ProFinal</h2><p>作者: StarsWhere</p><p>一个使用PyQt6和Matplotlib构建的交互式数据可视化工具。</p><p><b>v3.3 更新:</b></p><ul><li><b>一键导出:</b> 剖面图和全局统计数据可一键导出到输出目录。</li><li><b>公式探针:</b> 数据探针现在显示可视化所用的完整公式。</li><li><b>坐标剖面图:</b> 支持通过输入坐标来定义剖面线。</li><li><b>实时公式验证:</b> 输入框在语法错误时会变色并提示。</li><li><b>数据库维护:</b> 新增数据库信息显示和一键压缩优化功能。</li><li><b>多变量剖面图:</b> 剖面图窗口支持切换不同变量进行分析。</li><li><b>并行批量导出:</b> 多个视频导出任务可并行处理，加快速度。</li></ul>")
    def _force_reload_data(self):
        reply = QMessageBox.question(self, "确认重新导入", "这将删除现有数据库并从CSV文件重新导入所有数据。此操作不可撤销。\n\n是否继续？", QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.Cancel)
        if reply == QMessageBox.StandardButton.Yes:
            self.playback_handler.stop_playback()
            self.stats_handler.reset_global_stats()
            try: os.remove(self.data_manager.db_path)
            except Exception as e: self._on_error(f"删除旧数据库失败: {e}"); return
            self._initialize_project()

    def _change_project_directory(self):
        new_dir = QFileDialog.getExistingDirectory(self, "选择项目目录 (包含CSV文件)", self.project_dir)
        if new_dir and new_dir != self.project_dir:
            self.project_dir = new_dir; self.ui.data_dir_line_edit.setText(self.project_dir)
            self.playback_handler.stop_playback()
            self.stats_handler.reset_global_stats(); self.data_manager.clear_all()
            self._initialize_project()
            
    def _toggle_control_panel(self, checked): self.ui.control_panel.setVisible(checked)
    def _toggle_full_screen(self, checked): self.showFullScreen() if checked else self.showNormal()
    def _apply_cache_settings(self): self.data_manager.set_cache_size(self.ui.cache_size_spinbox.value()); self._update_frame_info()

    def _load_settings(self):
        self.restoreGeometry(self.settings.value("geometry", self.saveGeometry()))
        self.restoreState(self.settings.value("windowState", self.saveState()))
        self.ui.control_panel.setVisible(self.settings.value("panel_visible", True, type=bool)); self.ui.toggle_panel_action.setChecked(self.ui.control_panel.isVisible())
        self.ui.output_dir_line_edit.setText(self.output_dir); self._update_gpu_status_label()

    def _save_settings(self):
        self.settings.setValue("geometry", self.saveGeometry()); self.settings.setValue("windowState", self.saveState())
        self.settings.setValue("project_directory", self.project_dir); self.settings.setValue("output_directory", self.output_dir)
        self.settings.setValue("panel_visible", self.ui.control_panel.isVisible())
        if self.config_handler.current_config_file: self.settings.setValue("last_config_file", self.config_handler.current_config_file)

    def closeEvent(self, event):
        if not self.export_handler.on_main_window_close(): event.ignore(); return
        if self.config_handler.config_is_dirty:
            reply = QMessageBox.question(self, '未保存的修改', "退出前是否保存当前修改？", QMessageBox.StandardButton.Save | QMessageBox.StandardButton.Discard | QMessageBox.StandardButton.Cancel)
            if reply == QMessageBox.StandardButton.Save: self.config_handler.save_current_config()
            elif reply == QMessageBox.StandardButton.Cancel: event.ignore(); return
        self._save_settings(); self.playback_handler.stop_playback()
        if self.ui.plot_widget.thread_pool: self.ui.plot_widget.thread_pool.clear(); self.ui.plot_widget.thread_pool.waitForDone()
        if self.timeseries_dialog: self.timeseries_dialog.close()
        if self.profile_dialog: self.profile_dialog.close()
        super().closeEvent(event)

    def _update_gpu_status_label(self):
        status, color = ("GPU: 启用", "green") if self.ui.gpu_checkbox.isChecked() and is_gpu_available() else (("GPU: 可用", "orange") if is_gpu_available() else ("GPU: 不可用", "red"))
        self.ui.gpu_status_label.setText(status); self.ui.gpu_status_label.setStyleSheet(f"color: {color};")

    def _show_variable_menu(self, line_edit: QLineEdit, position: QPoint):
        menu = QMenu(self)
        def insert_text(text): line_edit.insert(f" {text} ")
        var_menu = menu.addMenu("数据变量")
        for var in sorted(self.data_manager.get_variables()): var_menu.addAction(var).triggered.connect(lambda checked=False, v=var: insert_text(v))
        if self.formula_engine.custom_global_variables:
            global_menu = menu.addMenu("全局常量")
            for g_var in sorted(self.formula_engine.custom_global_variables.keys()): global_menu.addAction(g_var).triggered.connect(lambda checked=False, v=g_var: insert_text(v))
        if self.formula_engine.science_constants:
            const_menu = menu.addMenu("科学常数")
            for const in sorted(self.formula_engine.science_constants.keys()): const_menu.addAction(const).triggered.connect(lambda checked=False, v=const: insert_text(v))
        if not menu.actions(): menu.addAction("无可用变量").setEnabled(False)
        menu.exec(position)
```
--- END OF FILE main_window.py ---

--- START OF FILE plot_widget.py ---
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import numpy as np
import pandas as pd
import logging
import traceback
import sys
from typing import Optional, Dict, Any, Tuple

from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
import matplotlib.ticker as ticker
import matplotlib.pyplot as plt
import matplotlib.font_manager as fm
from matplotlib.lines import Line2D
from scipy.interpolate import interpn, griddata

from PyQt6.QtWidgets import QWidget, QVBoxLayout
from PyQt6.QtCore import pyqtSignal, QObject, QRunnable, QThreadPool, Qt
from PyQt6.QtGui import QCursor

from src.core.rendering_core import prepare_gridded_data
from src.core.constants import VectorPlotType, StreamlineColor, PickerMode

logger = logging.getLogger(__name__)

class WorkerSignals(QObject):
    finished = pyqtSignal()
    error = pyqtSignal(str)
    result = pyqtSignal(dict)

class InterpolationWorker(QRunnable):
    def __init__(self, data, config, formula_engine):
        super().__init__()
        self.data = data
        self.config = config
        self.formula_engine = formula_engine
        self.signals = WorkerSignals()
        
    def run(self):
        try:
            result = prepare_gridded_data(self.data, self.config, self.formula_engine)
            self.signals.result.emit(result)
        except Exception as e:
            error_msg = f"插值或公式计算失败: {e}\n{traceback.format_exc()}"
            logger.error(error_msg)
            self.signals.error.emit(str(e))
        finally:
            self.signals.finished.emit()

class PlotWidget(QWidget):
    mouse_moved = pyqtSignal(float, float)
    probe_data_ready = pyqtSignal(dict)
    plot_rendered = pyqtSignal()
    value_picked = pyqtSignal(PickerMode, float)
    timeseries_point_picked = pyqtSignal(tuple)
    profile_line_defined = pyqtSignal(tuple, tuple)
    interpolation_error = pyqtSignal(str)

    def __init__(self, formula_engine, parent=None):
        super().__init__(parent)
        self.formula_engine = formula_engine
        self.figure = Figure(figsize=(12, 8), dpi=100, tight_layout=True)
        self.canvas = FigureCanvas(self.figure)
        self.ax = self.figure.add_subplot(111)
        layout = QVBoxLayout(self); layout.setContentsMargins(0,0,0,0); layout.addWidget(self.canvas)
        
        self.current_data: Optional[pd.DataFrame] = None
        self.interpolated_results: Dict[str, Any] = {}
        
        self.x_axis_formula, self.y_axis_formula, self.chart_title = 'x', 'y', ''
        self.use_gpu, self.heatmap_config, self.contour_config, self.vector_config = False, {}, {}, {}
        self.grid_resolution = (150, 150)
        self.analysis = {}
        
        self.heatmap_obj = self.contour_obj = self.colorbar_obj = self.vector_quiver_obj = self.vector_stream_obj = None
        
        self.is_dragging = False; self.drag_start_pos = None; self.picker_mode: Optional[PickerMode] = None
        self.profile_start_point: Optional[Tuple[float, float]] = None
        self.profile_preview_line: Optional[Line2D] = None
        self.last_mouse_coords: Optional[Tuple[float, float]] = None
        self.thread_pool = QThreadPool(); self.is_busy_interpolating = False
        
        self._connect_signals()
        self._setup_plot_style()

    def _connect_signals(self):
        self.canvas.mpl_connect('motion_notify_event', self._on_mouse_move)
        self.canvas.mpl_connect('scroll_event', self._on_scroll)
        self.canvas.mpl_connect('button_press_event', self._on_button_press)
        self.canvas.mpl_connect('button_release_event', self._on_button_release)

    def _get_platform_font(self) -> str:
        if sys.platform == "win32": return "Microsoft YaHei"
        elif sys.platform == "darwin": return "PingFang SC"
        font_options = ["WenQuanYi Zen Hei", "Noto Sans CJK SC", "Source Han Sans SC"]
        for font in font_options:
            if fm.findfont(font, fallback_to_default=False): return font
        return "sans-serif"

    def _setup_plot_style(self):
        font_name = self._get_platform_font()
        plt.rcParams['font.sans-serif'] = [font_name]
        plt.rcParams['axes.unicode_minus'] = False
        logger.info(f"使用字体: {font_name}")
        self.ax.grid(True, linestyle='--', alpha=0.5)

    def _update_plot_decorations(self):
        self.ax.set_xlabel(self.x_axis_formula); self.ax.set_ylabel(self.y_axis_formula)
        
        title = self.chart_title
        if not title:
            is_avg = self.analysis.get('time_average', {}).get('enabled', False)
            if is_avg:
                start = self.analysis['time_average']['start_frame']
                end = self.analysis['time_average']['end_frame']
                title = f"时间平均场 (帧 {start}-{end})"
            else:
                parts = []
                if self.heatmap_config.get('enabled'): parts.append(f"热力图: {self.heatmap_config['formula']}")
                if self.contour_config.get('enabled'): parts.append(f"等高线: {self.contour_config['formula']}")
                title = " | ".join(parts) if parts else "InterVis Plot"
        self.ax.set_title(title)
        
        formatter = ticker.ScalarFormatter(useMathText=True); formatter.set_scientific(True); formatter.set_powerlimits((-3, 3))
        self.ax.xaxis.set_major_formatter(formatter); self.ax.yaxis.set_major_formatter(formatter)

    def update_data(self, data: Optional[pd.DataFrame]):
        if self.is_busy_interpolating: return
        if data is None or data.empty:
             self.ax.clear(); self._setup_plot_style(); self.ax.text(0.5, 0.5, "无有效数据点", ha='center', va='center', transform=self.ax.transAxes); self.canvas.draw_idle()
             return

        self.current_data = data.copy(); self.is_busy_interpolating = True
        
        worker_config = {
            'x_axis_formula': self.x_axis_formula, 'y_axis_formula': self.y_axis_formula,
            'heatmap_config': self.heatmap_config, 'contour_config': self.contour_config,
            'vector_config': self.vector_config, 'use_gpu': self.use_gpu, 'grid_resolution': self.grid_resolution
        }
        
        worker = InterpolationWorker(self.current_data, worker_config, self.formula_engine)
        worker.signals.result.connect(self._on_interpolation_result)
        worker.signals.error.connect(self._on_worker_error)
        worker.signals.finished.connect(lambda: setattr(self, 'is_busy_interpolating', False))
        self.thread_pool.start(worker)

    def _on_worker_error(self, error_message: str):
        self.is_busy_interpolating = False
        logger.error(f"插值线程错误: {error_message}")
        self.interpolation_error.emit(error_message)

    def _on_interpolation_result(self, result: dict):
        is_initial_plot = not self.interpolated_results
        self.interpolated_results = result
        self.redraw(is_initial_plot)
        self.plot_rendered.emit()
        if self.last_mouse_coords: self.get_probe_data_at_coords(*self.last_mouse_coords)

    def set_config(self, **kwargs):
        for key, value in kwargs.items(): setattr(self, key, value)
    
    def redraw(self, is_initial: bool = False):
        if not self.interpolated_results: return
        self._remove_profile_preview()
        self._update_plot_decorations()
        self._draw_heatmap(); self._draw_contour(); self._draw_vector_plot()
        if is_initial: self.reset_view()
        self.canvas.draw_idle()
    
    def _draw_heatmap(self):
        data, gx, gy = self.interpolated_results.get('heatmap_data'), self.interpolated_results.get('grid_x'), self.interpolated_results.get('grid_y')
        
        if self.colorbar_obj: self.colorbar_obj.remove(); self.colorbar_obj = None
        if self.heatmap_obj: self.heatmap_obj.remove(); self.heatmap_obj = None

        if not self.heatmap_config.get('enabled') or data is None or gx is None: return

        vmin_str, vmax_str = self.heatmap_config.get('vmin'), self.heatmap_config.get('vmax')
        
        vmin = float(vmin_str) if vmin_str is not None and str(vmin_str).strip() != '' else None
        vmax = float(vmax_str) if vmax_str is not None and str(vmax_str).strip() != '' else None

        valid = data[~np.isnan(data)]
        if valid.size > 0:
            if vmin is None: vmin = np.min(valid)
            if vmax is None: vmax = np.max(valid)

        self.heatmap_obj = self.ax.pcolormesh(gx, gy, data, cmap=self.heatmap_config.get('colormap', 'viridis'), vmin=vmin, vmax=vmax, shading='gouraud')
        self.colorbar_obj = self.figure.colorbar(self.heatmap_obj, ax=self.ax, format=ticker.ScalarFormatter(useMathText=True))
        self.colorbar_obj.set_label(self.heatmap_config.get('formula', ''))

    def _draw_contour(self):
        if self.contour_obj:
            for coll in self.contour_obj.collections: coll.remove()
            self.contour_obj = None

        data, gx, gy = self.interpolated_results.get('contour_data'), self.interpolated_results.get('grid_x'), self.interpolated_results.get('grid_y')
        if not self.contour_config.get('enabled') or data is None or gx is None or np.all(np.isnan(data)): return

        self.contour_obj = self.ax.contour(gx, gy, data, levels=self.contour_config.get('levels', 10), colors=self.contour_config.get('colors', 'black'), linewidths=self.contour_config.get('linewidths', 1.0))
        if self.contour_config.get('show_labels'): self.ax.clabel(self.contour_obj, inline=True, fontsize=8, fmt='%.2e')

    def _draw_vector_plot(self):
        if self.vector_quiver_obj: self.vector_quiver_obj.remove(); self.vector_quiver_obj = None
        if self.vector_stream_obj: self.vector_stream_obj.lines.remove(); self.vector_stream_obj = None
        
        if not self.vector_config.get('enabled'): return
        plot_type = VectorPlotType.from_str(self.vector_config.get('type'))
        if plot_type == VectorPlotType.QUIVER: self._draw_quiver()
        else: self._draw_streamlines()

    def _draw_quiver(self):
        u, v, gx, gy = (self.interpolated_results.get(k) for k in ['vector_u_data', 'vector_v_data', 'grid_x', 'grid_y'])
        if u is None or v is None or gx is None: return
        opts = self.vector_config.get('quiver_options', {}); density = opts.get('density', 10); scale = opts.get('scale', 1.0)
        sl = slice(None, None, density)
        self.vector_quiver_obj = self.ax.quiver(gx[sl, sl], gy[sl, sl], u[sl, sl], v[sl, sl], scale=scale, scale_units='xy', angles='xy')

    def _draw_streamlines(self):
        u, v, gx, gy = (self.interpolated_results.get(k) for k in ['vector_u_data', 'vector_v_data', 'grid_x', 'grid_y'])
        if u is None or v is None or gx is None: return
        opts = self.vector_config.get('streamline_options', {}); density = opts.get('density', 1.5); lw = opts.get('linewidth', 1.0)
        color_by = StreamlineColor.from_str(opts.get('color_by'))
        
        color_data = 'black'
        if color_by == StreamlineColor.MAGNITUDE: color_data = np.sqrt(u**2 + v**2)
        elif color_by == StreamlineColor.U_COMPONENT: color_data = u
        elif color_by == StreamlineColor.V_COMPONENT: color_data = v
        
        self.vector_stream_obj = self.ax.streamplot(gx, gy, u, v, density=density, linewidth=lw, color=color_data, cmap='viridis' if isinstance(color_data, np.ndarray) else None)
        if isinstance(color_data, np.ndarray) and not self.colorbar_obj:
            self.colorbar_obj = self.figure.colorbar(self.vector_stream_obj.lines, ax=self.ax)
            self.colorbar_obj.set_label(f"流线 ({color_by.value})")

    def _on_mouse_move(self, event):
        if event.inaxes != self.ax or event.xdata is None: return
        self.mouse_moved.emit(event.xdata, event.ydata)
        self.last_mouse_coords = (event.xdata, event.ydata)
        if self.is_dragging:
            if self.drag_start_pos:
                dx, dy = event.xdata - self.drag_start_pos[0], event.ydata - self.drag_start_pos[1]
                xlim, ylim = self.drag_start_lims
                self.ax.set_xlim(xlim[0] - dx, xlim[1] - dx); self.ax.set_ylim(ylim[0] - dy, ylim[1] - dy)
                self.canvas.draw_idle()
        elif self.picker_mode == PickerMode.PROFILE_END and self.profile_start_point:
            self._update_profile_preview((event.xdata, event.ydata))
        elif not self.picker_mode:
            self.get_probe_data_at_coords(event.xdata, event.ydata)
    
    def get_probe_data_at_coords(self, x: float, y: float):
        if self.current_data is None or self.current_data.empty: return
        results = {'x': x, 'y': y, 'variables': {}, 'interpolated': {}}
        try:
            x_vals_formula = self.x_axis_formula or 'x'
            y_vals_formula = self.y_axis_formula or 'y'

            x_vals = self.current_data[x_vals_formula] if x_vals_formula in self.current_data else self.formula_engine.evaluate_formula(self.current_data, x_vals_formula)
            y_vals = self.current_data[y_vals_formula] if y_vals_formula in self.current_data else self.formula_engine.evaluate_formula(self.current_data, y_vals_formula)

            dist_sq = (x_vals - x)**2 + (y_vals - y)**2
            if not dist_sq.empty:
                idx = dist_sq.idxmin()
                results['variables'] = self.current_data.loc[idx].to_dict()
        except Exception as e: logger.debug(f"获取原始探针数据时出错: {e}")

        try:
            gx, gy = self.interpolated_results.get('grid_x'), self.interpolated_results.get('grid_y')
            if gx is not None and gy is not None:
                point, grid_coords = (y, x), (gy[:, 0], gx[0, :])
                for key, data in self.interpolated_results.items():
                    if 'data' in key and isinstance(data, np.ndarray):
                        val = interpn(grid_coords, data, point, method='linear', bounds_error=False, fill_value=np.nan)[0]
                        results['interpolated'][key.replace('_data', '')] = val
        except Exception as e: logger.debug(f"获取插值探针数据时出错: {e}")
        self.probe_data_ready.emit(results)

    def _on_scroll(self, event):
        if event.inaxes != self.ax: return
        sf = 1.1 if event.step < 0 else 1/1.1
        xlim, ylim = self.ax.get_xlim(), self.ax.get_ylim(); xd, yd = event.xdata, event.ydata
        nw, nh = (xlim[1] - xlim[0]) * sf, (ylim[1] - ylim[0]) * sf
        rx, ry = (xd - xlim[0]) / (xlim[1] - xlim[0]), (yd - ylim[0]) / (ylim[1] - ylim[0])
        self.ax.set_xlim([xd - nw * rx, xd + nw * (1 - rx)]); self.ax.set_ylim([yd - nh * ry, yd + nh * (1 - ry)])
        self.canvas.draw_idle()
    
    def _on_button_press(self, event):
        if event.inaxes != self.ax: return
        if event.button == 1:
            if self.picker_mode: self._handle_picker_click(event); return
            self.is_dragging, self.drag_start_pos = True, (event.xdata, event.ydata)
            self.drag_start_lims = self.ax.get_xlim(), self.ax.get_ylim()
            self.canvas.setCursor(Qt.CursorShape.ClosedHandCursor)
        elif event.button == 3:
            if self.picker_mode: # 右键取消选择模式
                self.set_picker_mode(None)
            else:
                self.reset_view()

    def _handle_picker_click(self, event):
        coords = (event.xdata, event.ydata)
        if self.picker_mode == PickerMode.TIMESERIES:
            self.timeseries_point_picked.emit(coords)
            self.set_picker_mode(None)
        elif self.picker_mode == PickerMode.PROFILE_START:
            self.profile_start_point = coords
            self.set_picker_mode(PickerMode.PROFILE_END)
        elif self.picker_mode == PickerMode.PROFILE_END:
            if self.profile_start_point:
                self.profile_line_defined.emit(self.profile_start_point, coords)
            self.set_picker_mode(None)
        else: # VMIN/VMAX
            data = self.interpolated_results.get('heatmap_data')
            if data is not None:
                val = self._get_interpolated_value_at_coord('heatmap_data', *coords)
                if val is not None and not np.isnan(val): self.value_picked.emit(self.picker_mode, float(val))
            self.set_picker_mode(None)
    
    def _get_interpolated_value_at_coord(self, key, x, y) -> Optional[float]:
        data, gx, gy = (self.interpolated_results.get(k) for k in [key, 'grid_x', 'grid_y'])
        if data is None or gx is None: return None
        try: return interpn((gy[:, 0], gx[0, :]), data, (y, x), method='linear', bounds_error=False, fill_value=np.nan)[0]
        except Exception as e: logger.warning(f"拾取/插值数值失败: {e}"); return None

    def _on_button_release(self, event):
        if event.button == 1 and self.is_dragging: 
            self.is_dragging, self.drag_start_pos = False, None
            self.canvas.setCursor(Qt.CursorShape.ArrowCursor)

    def set_picker_mode(self, mode: Optional[PickerMode]):
        self.picker_mode = mode
        if mode:
            self.canvas.setCursor(QCursor(Qt.CursorShape.CrossCursor))
        else:
            self.canvas.setCursor(Qt.CursorShape.ArrowCursor)
            self._remove_profile_preview()
            self.profile_start_point = None
            
    def _update_profile_preview(self, end_point):
        if not self.profile_start_point: return
        self._remove_profile_preview()
        self.profile_preview_line = Line2D(
            [self.profile_start_point[0], end_point[0]],
            [self.profile_start_point[1], end_point[1]],
            color='red', linestyle='--', marker='o'
        )
        self.ax.add_line(self.profile_preview_line)
        self.canvas.draw_idle()

    def _remove_profile_preview(self):
        if self.profile_preview_line:
            try:
                self.profile_preview_line.remove()
                self.profile_preview_line = None
            except ValueError:
                self.profile_preview_line = None
        self.canvas.draw_idle()

    def save_figure(self, filename: str, dpi: int = 300):
        try: self.figure.savefig(filename, dpi=dpi, bbox_inches='tight'); return True
        except Exception as e: logger.error(f"保存图形失败: {e}"); return False
        
    def reset_view(self):
        if self.interpolated_results and 'grid_x' in self.interpolated_results and self.interpolated_results['grid_x'] is not None:
            gx, gy = self.interpolated_results['grid_x'], self.interpolated_results['grid_y']
            if np.all(np.isnan(gx)) or np.all(np.isnan(gy)): return
            x_min, x_max, y_min, y_max = np.nanmin(gx), np.nanmax(gx), np.nanmin(gy), np.nanmax(gy)
            if any(np.isnan(v) for v in [x_min, x_max, y_min, y_max]): return
            
            xr = x_max - x_min or 1; yr = y_max - y_min or 1; m = 0.05
            self.ax.set_xlim(x_min - m * xr, x_max + m * xr); self.ax.set_ylim(y_min - m * yr, y_max + m * yr)
            self.ax.set_aspect('auto', adjustable='box')
            self.canvas.draw_idle()
```
--- END OF FILE plot_widget.py ---

--- START OF FILE profile_plot_dialog.py ---
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
一维剖面图对话框
"""
import logging
import os
from datetime import datetime
import numpy as np
import pandas as pd
from typing import Tuple, Dict, Any
from scipy.ndimage import map_coordinates

from PyQt6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QPushButton, QMessageBox,
    QLabel, QComboBox
)
from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
import matplotlib.ticker as ticker

logger = logging.getLogger(__name__)

class ProfilePlotDialog(QDialog):
    """显示一维剖面图的对话框，支持多变量选择。"""
    
    def __init__(self, start_point: Tuple, end_point: Tuple, interpolated_data: Dict, 
                 available_variables: Dict[str, str], output_dir: str, parent=None):
        super().__init__(parent)
        self.start_point = start_point
        self.end_point = end_point
        self.interp_data = interpolated_data
        self.available_variables = available_variables
        self.output_dir = output_dir
        self.profile_data_cache = {}

        self.setWindowTitle("一维剖面图分析")
        self.setMinimumSize(800, 600)

        main_layout = QVBoxLayout(self)

        # --- Controls Layout ---
        controls_layout = QHBoxLayout()
        title = f"从 ({start_point[0]:.2f}, {start_point[1]:.2f}) 到 ({end_point[0]:.2f}, {end_point[1]:.2f})"
        controls_layout.addWidget(QLabel(title))
        controls_layout.addStretch()
        
        controls_layout.addWidget(QLabel("变量:"))
        self.variable_combo = QComboBox()
        self.populate_variables()
        self.variable_combo.currentIndexChanged.connect(self._update_plot)
        controls_layout.addWidget(self.variable_combo)

        self.export_button = QPushButton("一键导出数据")
        self.export_button.setToolTip(f"将当前剖面数据导出到项目输出目录")
        self.export_button.clicked.connect(self.export_data)
        controls_layout.addWidget(self.export_button)
        main_layout.addLayout(controls_layout)

        # --- Matplotlib Canvas ---
        self.figure = Figure(figsize=(8, 5), dpi=100, tight_layout=True)
        self.canvas = FigureCanvas(self.figure)
        self.ax = self.figure.add_subplot(111)
        main_layout.addWidget(self.canvas)
        
        # --- Initial Plot ---
        self._update_plot()

    def populate_variables(self):
        """用可用变量填充下拉菜单。"""
        for key, formula in sorted(self.available_variables.items()):
            display_text = f"{key} ({formula})" if formula else key
            self.variable_combo.addItem(display_text, key)
        
        if 'heatmap' in self.available_variables:
             self.variable_combo.setCurrentText(f"heatmap ({self.available_variables['heatmap']})")

    def _calculate_profile(self, variable_key: str) -> pd.DataFrame:
        """为单个变量计算剖面数据，并缓存结果。"""
        if variable_key in self.profile_data_cache:
            return self.profile_data_cache[variable_key]

        gx, gy = self.interp_data.get('grid_x'), self.interp_data.get('grid_y')
        target_data = self.interp_data.get(f'{variable_key}_data')

        if gx is None or gy is None or target_data is None:
            raise ValueError(f"缺少变量 '{variable_key}' 的有效插值数据。")

        x_coords, y_coords = gx[0, :], gy[:, 0]
        start_idx_x = np.interp(self.start_point[0], x_coords, np.arange(len(x_coords)))
        start_idx_y = np.interp(self.start_point[1], y_coords, np.arange(len(y_coords)))
        end_idx_x = np.interp(self.end_point[0], x_coords, np.arange(len(x_coords)))
        end_idx_y = np.interp(self.end_point[1], y_coords, np.arange(len(y_coords)))
        
        num_points = int(np.hypot(end_idx_x - start_idx_x, end_idx_y - start_idx_y)) * 2
        num_points = max(100, num_points)
        
        line_y_indices = np.linspace(start_idx_y, end_idx_y, num_points)
        line_x_indices = np.linspace(start_idx_x, end_idx_x, num_points)
        
        profile_values = map_coordinates(target_data, np.vstack((line_y_indices, line_x_indices)), order=1, prefilter=False)
        
        distance = np.hypot(self.end_point[0] - self.start_point[0], self.end_point[1] - self.start_point[1])
        profile_distance = np.linspace(0, distance, num_points)
        
        df = pd.DataFrame({'distance': profile_distance, 'value': profile_values})
        self.profile_data_cache[variable_key] = df
        return df

    def _update_plot(self):
        """根据下拉菜单的选择，计算并绘制剖面数据。"""
        self.ax.clear()
        selected_key = self.variable_combo.currentData()
        if not selected_key:
            self.ax.text(0.5, 0.5, "请选择一个变量进行分析", ha='center'); self.canvas.draw(); return

        try:
            df = self._calculate_profile(selected_key)
            self.ax.plot(df['distance'], df['value'])
            
            display_text = self.variable_combo.currentText()
            self.ax.set_title(f"变量剖面图: {display_text}")
            self.ax.set_xlabel("沿线的距离")
            self.ax.set_ylabel(f"值")
            self.ax.grid(True, linestyle='--', alpha=0.6)
            
            formatter = ticker.ScalarFormatter(useMathText=True)
            formatter.set_scientific(True); formatter.set_powerlimits((-3, 3))
            self.ax.yaxis.set_major_formatter(formatter)

        except Exception as e:
            logger.error(f"绘制剖面图失败: {e}", exc_info=True)
            self.ax.text(0.5, 0.5, f"绘图失败:\n{e}", ha='center', color='red')
            
        self.canvas.draw()

    def export_data(self):
        selected_key = self.variable_combo.currentData()
        if not selected_key or selected_key not in self.profile_data_cache:
            QMessageBox.warning(self, "无数据", "没有可导出的剖面数据。"); return
            
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"profile_{selected_key}_{timestamp}.csv"
        filepath = os.path.join(self.output_dir, filename)
            
        try:
            df_to_export = self.profile_data_cache[selected_key]
            df_to_export.to_csv(filepath, index=False)
            QMessageBox.information(self, "成功", f"剖面数据已保存到:\n{filepath}")
        except Exception as e:
            QMessageBox.critical(self, "保存失败", f"无法保存文件: {e}")
```
--- END OF FILE profile_plot_dialog.py ---

--- START OF FILE stats_handler.py ---
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
全局统计处理器
"""
import logging
import os
from typing import Dict
from PyQt6.QtWidgets import QMessageBox, QFileDialog
from datetime import datetime
from src.ui.dialogs import StatsProgressDialog
from src.core.workers import GlobalStatsWorker, CustomGlobalStatsWorker

logger = logging.getLogger(__name__)

class StatsHandler:
    """处理所有与全局统计计算、UI更新和导出相关的逻辑。"""

    def __init__(self, main_window, ui, data_manager, formula_engine):
        self.main_window = main_window
        self.ui = ui
        self.dm = data_manager
        self.formula_engine = formula_engine
        
        self.output_dir = main_window.output_dir
        self.stats_progress_dialog = None
        self.stats_worker = None
        self.custom_stats_worker = None

    def connect_signals(self):
        self.ui.recalc_basic_stats_btn.clicked.connect(self.start_global_stats_calculation)
        self.ui.save_and_calc_custom_stats_btn.clicked.connect(self.start_custom_stats_calculation)
        self.ui.export_stats_btn.clicked.connect(self.export_global_stats)
        self.ui.custom_stats_help_action.triggered.connect(lambda: self.main_window._show_help("custom_stats"))

    def reset_global_stats(self):
        """当数据重载时调用，重置统计信息和UI状态。"""
        self.dm.clear_global_stats()
        self.formula_engine.update_custom_global_variables({})
        self.ui.stats_results_text.setText("数据已重载。")
        self.ui.custom_stats_input.clear()
        self.ui.export_stats_btn.setEnabled(False)
        self.ui.save_and_calc_custom_stats_btn.setEnabled(False)

    def load_definitions_and_stats(self):
        """从数据库加载统计和定义，并更新UI。"""
        self.dm.load_global_stats()
        self.formula_engine.update_custom_global_variables(self.dm.global_stats)
        
        definitions = self.dm.load_custom_definitions()
        self.ui.custom_stats_input.setPlainText("\n".join(definitions))
        
        self.update_stats_display()
        
        has_stats = bool(self.dm.global_stats)
        self.ui.export_stats_btn.setEnabled(has_stats)
        self.ui.save_and_calc_custom_stats_btn.setEnabled(True)
    
    def start_global_stats_calculation(self):
        """强制重新计算所有变量的基础统计数据。"""
        if self.dm.get_frame_count() == 0: return
        reply = QMessageBox.question(self.main_window, "确认", "这将重新计算所有变量的基础统计数据并覆盖现有值。是否继续？", QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        if reply != QMessageBox.StandardButton.Yes: return
        
        self.stats_progress_dialog = StatsProgressDialog(self.main_window, "重新计算基础统计")
        all_vars = self.dm.get_variables()
        self.stats_worker = GlobalStatsWorker(self.dm, all_vars)
        self.stats_worker.progress.connect(self.stats_progress_dialog.update_progress)
        self.stats_worker.finished.connect(self.on_global_stats_finished)
        self.stats_worker.error.connect(self.on_stats_error)
        self.stats_worker.start()
        self.stats_progress_dialog.exec()

    def on_global_stats_finished(self):
        """在基础统计计算完成后调用。"""
        if self.stats_progress_dialog: self.stats_progress_dialog.accept()
        self.dm.load_global_stats() # 从数据库重新加载以获取最新值
        self.update_stats_display()
        self.formula_engine.update_custom_global_variables(self.dm.global_stats)
        self.main_window._trigger_auto_apply()
        QMessageBox.information(self.main_window, "计算完成", "基础统计数据已更新。")

    def start_custom_stats_calculation(self):
        definitions_text = self.ui.custom_stats_input.toPlainText().strip()
        definitions = [line.strip() for line in definitions_text.split('\n') if line.strip() and not line.strip().startswith('#')]
        
        try:
            self.dm.save_custom_definitions(definitions)
            logger.info("自定义常量定义已保存。")
        except Exception as e:
            self.on_stats_error(f"保存定义失败: {e}")
            return
            
        self.stats_progress_dialog = StatsProgressDialog(self.main_window, "正在计算自定义常量")
        self.custom_stats_worker = CustomGlobalStatsWorker(self.dm, definitions)
        self.custom_stats_worker.progress.connect(self.stats_progress_dialog.update_progress)
        self.custom_stats_worker.finished.connect(self.on_custom_stats_finished)
        self.custom_stats_worker.error.connect(self.on_stats_error)
        self.custom_stats_worker.start()
        self.stats_progress_dialog.exec()

    def on_custom_stats_finished(self):
        if self.stats_progress_dialog: self.stats_progress_dialog.accept()
        self.dm.load_global_stats() # 重新加载以包含新计算的常量
        self.update_stats_display()
        self.formula_engine.update_custom_global_variables(self.dm.global_stats)
        self.main_window._trigger_auto_apply()
        QMessageBox.information(self.main_window, "计算完成", "自定义常量已计算并更新。")

    def on_stats_error(self, error_msg: str):
        if self.stats_progress_dialog: self.stats_progress_dialog.accept()
        QMessageBox.critical(self.main_window, "计算失败", f"计算时发生错误: \n{error_msg}")

    def update_stats_display(self):
        all_stats = self.dm.global_stats
        if not all_stats:
            self.ui.stats_results_text.setText("无统计结果。"); return
        
        text = "\n".join([f"{k}: {v:.6e}" for k, v in sorted(all_stats.items())])
        self.ui.stats_results_text.setText(text)
        self.ui.export_stats_btn.setEnabled(True)

    def export_global_stats(self):
        if not self.dm.global_stats:
            QMessageBox.warning(self.main_window, "导出失败", "没有可导出的统计结果。"); return

        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        filename = f"global_stats_{timestamp}.csv"
        filepath = os.path.join(self.output_dir, filename)

        try:
            with open(filepath, 'w', encoding='utf-8', newline='') as f:
                import csv
                writer = csv.writer(f)
                writer.writerow(["Name", "Value", "Definition (if custom)"])
                
                custom_names = self.dm.custom_global_formulas.keys()
                
                for name, value in sorted(self.dm.global_stats.items()):
                    formula = self.dm.custom_global_formulas.get(name, "")
                    writer.writerow([name, f"{value:.6e}", formula])
            
            QMessageBox.information(self.main_window, "导出成功", f"统计结果已保存到:\n{filepath}")
        except Exception as e:
            QMessageBox.critical(self.main_window, "导出失败", f"无法保存文件: {e}")
```
--- END OF FILE stats_handler.py ---

--- START OF FILE timeseries_dialog.py ---
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
时间序列图表对话框
"""
import logging
import numpy as np
from typing import Tuple, Optional
from PyQt6.QtWidgets import QDialog, QVBoxLayout, QHBoxLayout, QComboBox, QPushButton, QLabel, QWidget
from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
import matplotlib.ticker as ticker

logger = logging.getLogger(__name__)

class TimeSeriesDialog(QDialog):
    """一个显示时间序列及其FFT的对话框。"""
    
    def __init__(self, point_coords: Tuple[float, float], data_manager, filter_clause: str, parent=None):
        super().__init__(parent)
        self.dm = data_manager
        self.point_coords = point_coords
        self.filter_clause = filter_clause
        self.current_df = None
        
        self.setWindowTitle(f"时间序列分析 @ ({point_coords[0]:.2f}, {point_coords[1]:.2f})")
        self.setMinimumSize(800, 700)

        main_layout = QVBoxLayout(self)

        controls_layout = QHBoxLayout()
        controls_layout.addWidget(QLabel("选择变量:"))
        self.variable_combo = QComboBox()
        self.variable_combo.addItems(self.dm.get_variables())
        self.variable_combo.currentIndexChanged.connect(self.plot_data)
        controls_layout.addWidget(self.variable_combo)
        controls_layout.addStretch()
        self.fft_button = QPushButton("计算 FFT")
        self.fft_button.clicked.connect(self.plot_fft)
        self.fft_button.setEnabled(False)
        controls_layout.addWidget(self.fft_button)
        main_layout.addLayout(controls_layout)

        self.figure = Figure(figsize=(8, 6), dpi=100)
        self.canvas = FigureCanvas(self.figure)
        # 创建两个子图，一个用于时间序列，一个用于FFT
        self.ax_time = self.figure.add_subplot(2, 1, 1)
        self.ax_fft = self.figure.add_subplot(2, 1, 2)
        main_layout.addWidget(self.canvas)
        
        self.figure.tight_layout(pad=3.0)
        self.plot_data()

    def plot_data(self):
        selected_variable = self.variable_combo.currentText()
        if not selected_variable: return

        self.ax_time.clear(); self.ax_fft.clear()
        self.ax_fft.set_yticklabels([]); self.ax_fft.set_xticklabels([])
        self.ax_fft.set_title("快速傅里叶变换 (FFT)")
        self.ax_fft.set_xlabel("频率 (Hz)")
        self.ax_fft.set_ylabel("振幅")
        
        try:
            # Use a slightly larger tolerance for picking points
            x_range = self.dm.global_stats.get('x_global_max', 1) - self.dm.global_stats.get('x_global_min', 0)
            y_range = self.dm.global_stats.get('y_global_max', 1) - self.dm.global_stats.get('y_global_min', 0)
            tolerance = max(x_range * 0.01, y_range * 0.01, 1e-6)

            self.current_df = self.dm.get_timeseries_at_point(selected_variable, self.point_coords, tolerance)

            if self.current_df is None or self.current_df.empty:
                self.ax_time.text(0.5, 0.5, "在此位置找不到时间序列数据", ha='center', va='center', transform=self.ax_time.transAxes)
                self.fft_button.setEnabled(False)
            else:
                self.ax_time.plot(self.current_df['timestamp'], self.current_df[selected_variable], marker='.', linestyle='-')
                self.ax_time.set_title(f"'{selected_variable}' 的时间演化")
                self.ax_time.set_xlabel("时间戳")
                self.ax_time.set_ylabel(f"值 ({selected_variable})")
                self.ax_time.grid(True, linestyle='--', alpha=0.6)
                
                formatter = ticker.ScalarFormatter(useMathText=True); formatter.set_scientific(True); formatter.set_powerlimits((-3, 3))
                self.ax_time.yaxis.set_major_formatter(formatter)
                
                is_valid_for_fft = len(self.current_df) > 1 and np.all(np.diff(self.current_df['timestamp']) > 0)
                self.fft_button.setEnabled(is_valid_for_fft)

        except Exception as e:
            logger.error(f"绘制时间序列图失败: {e}", exc_info=True)
            self.ax_time.text(0.5, 0.5, f"绘图失败:\n{e}", ha='center', va='center', color='red')
            self.fft_button.setEnabled(False)
            
        self.canvas.draw()

    def plot_fft(self):
        if self.current_df is None or self.current_df.empty: return
        
        selected_variable = self.variable_combo.currentText()
        signal = self.current_df[selected_variable].values
        timestamps = self.current_df['timestamp'].values
        
        N = len(signal)
        if N < 2: return
        
        time_diffs = np.diff(timestamps)
        if np.any(time_diffs <= 0):
            self.ax_fft.clear()
            self.ax_fft.text(0.5, 0.5, "时间戳不均匀或无效，无法计算FFT", ha='center', color='red')
            self.canvas.draw(); return
            
        T = np.mean(time_diffs)

        yf = np.fft.fft(signal - np.mean(signal)) # 减去均值
        xf = np.fft.fftfreq(N, T)[:N//2]
        
        self.ax_fft.clear()
        self.ax_fft.plot(xf, 2.0/N * np.abs(yf[0:N//2]))
        self.ax_fft.set_title(f"'{selected_variable}' 的快速傅里叶变换 (FFT)")
        self.ax_fft.set_xlabel("频率 (Hz)")
        self.ax_fft.set_ylabel("振幅")
        self.ax_fft.grid(True, linestyle='--', alpha=0.6)
        self.canvas.draw()
```
--- END OF FILE timeseries_dialog.py ---

--- START OF FILE ui_setup.py ---
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
主窗口UI创建与布局模块
"""
import os
from PyQt6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QGridLayout,
    QSplitter, QGroupBox, QLabel, QComboBox, QLineEdit, QPushButton,
    QSlider, QSpinBox, QDoubleSpinBox, QCheckBox, QTextEdit,
    QStatusBar, QToolBar, QScrollArea, QTabWidget, QFrame
)
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QAction, QFont, QIcon

from src.visualization.plot_widget import PlotWidget
from src.core.constants import VectorPlotType, StreamlineColor, PickerMode

class UiMainWindow:
    """此类负责创建和布局主窗口的所有UI组件。"""
    def setup_ui(self, main_window: QMainWindow, formula_engine):
        main_window.setWindowTitle("InterVis v3.3-ProFinal")
        main_window.setGeometry(100, 100, 1600, 950)
        
        central_widget = QWidget()
        main_window.setCentralWidget(central_widget)
        
        main_layout = QHBoxLayout(central_widget)
        self.main_splitter = QSplitter(Qt.Orientation.Horizontal)
        main_layout.addWidget(self.main_splitter)
        
        self.plot_widget = PlotWidget(formula_engine)
        self.main_splitter.addWidget(self.plot_widget)
        
        self.control_panel = self._create_control_panel(main_window)
        self.main_splitter.addWidget(self.control_panel)
        
        self.main_splitter.setSizes([1200, 450])
        self.main_splitter.setStretchFactor(0, 1)
        
        self._create_menu_bar(main_window)
        self._create_tool_bar(main_window)
        self._create_status_bar(main_window)

    def _create_control_panel(self, parent_window) -> QWidget:
        panel = QWidget(); panel.setMaximumWidth(450); panel.setMinimumWidth(400)
        main_layout = QVBoxLayout(panel)
        self.tab_widget = QTabWidget()
        self.tab_widget.addTab(self._create_visualization_tab(parent_window), "可视化")
        self.tab_widget.addTab(self._create_analysis_tab(parent_window), "分析")
        self.tab_widget.addTab(self._create_compute_tab(parent_window), "逐帧计算")
        self.tab_widget.addTab(self._create_statistics_tab(parent_window), "全局统计")
        self.tab_widget.addTab(self._create_datamanagement_tab(parent_window), "数据管理")
        self.tab_widget.addTab(self._create_export_tab(parent_window), "导出与性能")
        main_layout.addWidget(self.tab_widget)
        main_layout.addWidget(self._create_playback_group())
        main_layout.addWidget(self._create_path_group())
        return panel

    def _create_formula_input(self, label_text, placeholder, parent_window, help_method):
        layout = QHBoxLayout(); line_edit = QLineEdit(); line_edit.setPlaceholderText(placeholder)
        vars_btn = QPushButton("变量"); vars_btn.setToolTip("插入可用变量或常量")
        vars_btn.clicked.connect(lambda: parent_window._show_variable_menu(line_edit, vars_btn.mapToGlobal(vars_btn.rect().bottomLeft())))
        help_btn = QPushButton("?"); help_btn.setFixedSize(25, 25); help_btn.setToolTip("打开相关帮助 (F1/F2)"); help_btn.clicked.connect(help_method)
        layout.addWidget(line_edit); layout.addWidget(vars_btn); layout.addWidget(help_btn)
        return QLabel(label_text), layout, line_edit
    
    def _create_visualization_tab(self, parent_window) -> QWidget:
        tab = QWidget(); layout = QVBoxLayout(tab); scroll_area = QScrollArea(); scroll_widget = QWidget(); scroll_layout = QVBoxLayout(scroll_widget)
        
        time_group = QGroupBox("时间分析")
        time_layout = QGridLayout(time_group)
        time_layout.addWidget(QLabel("分析模式:"), 0, 0)
        self.time_analysis_mode_combo = QComboBox(); self.time_analysis_mode_combo.addItems(["瞬时场", "时间平均场"])
        time_layout.addWidget(self.time_analysis_mode_combo, 0, 1)
        self.time_analysis_help_btn = QPushButton("?"); self.time_analysis_help_btn.setFixedSize(25, 25)
        self.time_analysis_help_btn.setToolTip("打开时间分析功能帮助")
        time_layout.addWidget(self.time_analysis_help_btn, 0, 2)

        self.time_average_range_widget = QWidget()
        range_layout = QGridLayout(self.time_average_range_widget)
        range_layout.setContentsMargins(0, 5, 0, 0)
        self.time_avg_start_slider = QSlider(Qt.Orientation.Horizontal); self.time_avg_start_spinbox = QSpinBox()
        self.time_avg_end_slider = QSlider(Qt.Orientation.Horizontal); self.time_avg_end_spinbox = QSpinBox()
        self.time_avg_start_spinbox.setMinimumWidth(60); self.time_avg_end_spinbox.setMinimumWidth(60)
        range_layout.addWidget(QLabel("起始帧:"), 0, 0); range_layout.addWidget(self.time_avg_start_slider, 0, 1); range_layout.addWidget(self.time_avg_start_spinbox, 0, 2)
        range_layout.addWidget(QLabel("结束帧:"), 1, 0); range_layout.addWidget(self.time_avg_end_slider, 1, 1); range_layout.addWidget(self.time_avg_end_spinbox, 1, 2)
        time_layout.addWidget(self.time_average_range_widget, 1, 0, 1, 3)
        scroll_layout.addWidget(time_group)

        axis_group = QGroupBox("坐标轴与标题"); axis_layout = QGridLayout(axis_group)
        title_label, title_layout, self.chart_title_edit = self._create_formula_input("图表标题:", "例: Frame {frame_index}", parent_window, lambda: parent_window._show_help("axis_title"))
        axis_layout.addWidget(title_label, 0, 0); axis_layout.addLayout(title_layout, 0, 1)
        x_label, x_layout, self.x_axis_formula = self._create_formula_input("X轴公式:", "默认为 'x'", parent_window, lambda: parent_window._show_help("formula"))
        axis_layout.addWidget(x_label, 1, 0); axis_layout.addLayout(x_layout, 1, 1)
        y_label, y_layout, self.y_axis_formula = self._create_formula_input("Y轴公式:", "默认为 'y'", parent_window, lambda: parent_window._show_help("formula"))
        axis_layout.addWidget(y_label, 2, 0); axis_layout.addLayout(y_layout, 2, 1)
        scroll_layout.addWidget(axis_group)

        heatmap_group = QGroupBox("背景热力图"); heatmap_group.setCheckable(True); self.heatmap_enabled = heatmap_group; h_layout = QGridLayout(heatmap_group)
        heat_label, heat_layout, self.heatmap_formula = self._create_formula_input("可视化公式:", "例: sqrt(u**2 + v**2)", parent_window, lambda: parent_window._show_help("formula"))
        h_layout.addWidget(heat_label, 0, 0); h_layout.addLayout(heat_layout, 0, 1)
        h_layout.addWidget(QLabel("颜色映射:"), 1, 0); self.heatmap_colormap = QComboBox(); self.heatmap_colormap.addItems(['viridis', 'plasma', 'inferno', 'magma', 'jet', 'coolwarm', 'RdBu_r']); h_layout.addWidget(self.heatmap_colormap, 1, 1)
        min_layout = QHBoxLayout(); self.heatmap_vmin = QLineEdit(); self.pick_vmin_btn = QPushButton("拾取"); self.pick_vmin_btn.clicked.connect(lambda: self.plot_widget.set_picker_mode(PickerMode.VMIN)); min_layout.addWidget(self.heatmap_vmin); min_layout.addWidget(self.pick_vmin_btn)
        max_layout = QHBoxLayout(); self.heatmap_vmax = QLineEdit(); self.pick_vmax_btn = QPushButton("拾取"); self.pick_vmax_btn.clicked.connect(lambda: self.plot_widget.set_picker_mode(PickerMode.VMAX)); max_layout.addWidget(self.heatmap_vmax); max_layout.addWidget(self.pick_vmax_btn)
        h_layout.addWidget(QLabel("最小值:"), 2, 0); h_layout.addLayout(min_layout, 2, 1); h_layout.addWidget(QLabel("最大值:"), 3, 0); h_layout.addLayout(max_layout, 3, 1)
        scroll_layout.addWidget(heatmap_group)
        
        contour_group = QGroupBox("前景等高线"); contour_group.setCheckable(True); self.contour_enabled = contour_group; c_layout = QGridLayout(contour_group)
        contour_label, contour_layout, self.contour_formula = self._create_formula_input("可视化公式:", "例: p - mean(p)", parent_window, lambda: parent_window._show_help("formula"))
        c_layout.addWidget(contour_label, 0, 0); c_layout.addLayout(contour_layout, 0, 1)
        c_layout.addWidget(QLabel("等高线数:"), 1, 0); self.contour_levels = QSpinBox(); self.contour_levels.setRange(2, 100); self.contour_levels.setValue(10); c_layout.addWidget(self.contour_levels, 1, 1)
        c_layout.addWidget(QLabel("线条颜色:"), 2, 0); self.contour_colors = QComboBox(); self.contour_colors.addItems(['black', 'white', 'red', 'blue', 'grey']); c_layout.addWidget(self.contour_colors, 2, 1)
        c_layout.addWidget(QLabel("线条宽度:"), 3, 0); self.contour_linewidth = QDoubleSpinBox(); self.contour_linewidth.setRange(0.1, 10.0); self.contour_linewidth.setValue(1.0); self.contour_linewidth.setSingleStep(0.1); c_layout.addWidget(self.contour_linewidth, 3, 1)
        self.contour_labels = QCheckBox("显示数值标签"); self.contour_labels.setChecked(True); c_layout.addWidget(self.contour_labels, 4, 0, 1, 2)
        scroll_layout.addWidget(contour_group)

        vector_group = QGroupBox("矢量/流线图"); vector_group.setCheckable(True); self.vector_enabled = vector_group; v_layout = QGridLayout(vector_group)
        v_layout.addWidget(QLabel("绘图类型:"), 0, 0); self.vector_plot_type = QComboBox()
        for item in VectorPlotType: self.vector_plot_type.addItem(item.value, item)
        v_layout.addWidget(self.vector_plot_type, 0, 1)
        u_label, u_layout, self.vector_u_formula = self._create_formula_input("U分量公式:", "例: u - u_global_mean", parent_window, lambda: parent_window._show_help("formula"))
        v_label, v_layout_input, self.vector_v_formula = self._create_formula_input("V分量公式:", "例: v - v_global_mean", parent_window, lambda: parent_window._show_help("formula"))
        v_layout.addWidget(u_label, 1, 0); v_layout.addLayout(u_layout, 1, 1); v_layout.addWidget(v_label, 2, 0); v_layout.addLayout(v_layout_input, 2, 1)
        
        self.quiver_options_group = QGroupBox("矢量图选项"); quiver_layout = QGridLayout(self.quiver_options_group)
        quiver_layout.addWidget(QLabel("矢量密度:"), 0, 0); self.quiver_density_spinbox = QSpinBox(); self.quiver_density_spinbox.setRange(1, 50); self.quiver_density_spinbox.setValue(10); quiver_layout.addWidget(self.quiver_density_spinbox, 0, 1)
        quiver_layout.addWidget(QLabel("矢量缩放:"), 1, 0); self.quiver_scale_spinbox = QDoubleSpinBox(); self.quiver_scale_spinbox.setRange(0.1, 100.0); self.quiver_scale_spinbox.setValue(1.0); quiver_layout.addWidget(self.quiver_scale_spinbox, 1, 1)
        v_layout.addWidget(self.quiver_options_group, 3, 0, 1, 2)

        self.streamline_options_group = QGroupBox("流线图选项"); stream_layout = QGridLayout(self.streamline_options_group)
        stream_layout.addWidget(QLabel("流线密度:"), 0, 0); self.stream_density_spinbox = QDoubleSpinBox(); self.stream_density_spinbox.setRange(0.2, 10.0); self.stream_density_spinbox.setValue(1.5); stream_layout.addWidget(self.stream_density_spinbox, 0, 1)
        stream_layout.addWidget(QLabel("流线线宽:"), 1, 0); self.stream_linewidth_spinbox = QDoubleSpinBox(); self.stream_linewidth_spinbox.setRange(0.2, 10.0); self.stream_linewidth_spinbox.setValue(1.0); stream_layout.addWidget(self.stream_linewidth_spinbox, 1, 1)
        stream_layout.addWidget(QLabel("流线颜色:"), 2, 0); self.stream_color_combo = QComboBox()
        for item in StreamlineColor: self.stream_color_combo.addItem(item.value, item)
        stream_layout.addWidget(self.stream_color_combo, 2, 1)
        v_layout.addWidget(self.streamline_options_group, 4, 0, 1, 2)
        scroll_layout.addWidget(vector_group)
        
        scroll_layout.addStretch(); scroll_widget.setLayout(scroll_layout); scroll_area.setWidget(scroll_widget); scroll_area.setWidgetResizable(True); layout.addWidget(scroll_area)
        return tab

    def _create_analysis_tab(self, parent_window) -> QWidget:
        tab = QWidget()
        layout = QVBoxLayout(tab)
        
        analysis_splitter = QSplitter(Qt.Orientation.Vertical)
        
        probe_group = QGroupBox("数据探针")
        probe_layout = QVBoxLayout(probe_group)
        coord_layout = QHBoxLayout()
        coord_layout.addWidget(QLabel("鼠标坐标:"))
        self.probe_coord_label = QLabel("(0.00, 0.00)")
        self.probe_coord_label.setFont(QFont("monospace"))
        coord_layout.addWidget(self.probe_coord_label)
        coord_layout.addStretch()
        probe_layout.addLayout(coord_layout)
        self.probe_text = QTextEdit()
        self.probe_text.setReadOnly(True)
        self.probe_text.setFont(QFont("Courier New", 9))
        self.probe_text.setLineWrapMode(QTextEdit.LineWrapMode.NoWrap)
        probe_layout.addWidget(self.probe_text)
        analysis_splitter.addWidget(probe_group)

        tools_container = QWidget()
        tools_main_layout = QVBoxLayout(tools_container)
        tools_main_layout.setContentsMargins(0, 0, 0, 0)
        
        tools_group = QGroupBox("分析工具")
        tools_layout = QGridLayout(tools_group)
        self.pick_timeseries_btn = QPushButton("拾取时间序列点"); self.pick_timeseries_btn.setCheckable(True)
        tools_layout.addWidget(self.pick_timeseries_btn, 0, 0)
        self.draw_profile_btn = QPushButton("绘制剖面图"); self.draw_profile_btn.setCheckable(True)
        tools_layout.addWidget(self.draw_profile_btn, 0, 1)
        
        self.pick_by_coords_btn = QPushButton("按坐标拾取...")
        tools_layout.addWidget(self.pick_by_coords_btn, 1, 0)
        self.draw_profile_by_coords_btn = QPushButton("按坐标绘制剖面...")
        tools_layout.addWidget(self.draw_profile_by_coords_btn, 1, 1)
        
        self.analysis_help_btn = QPushButton("帮助 (?)")
        self.analysis_help_btn.setToolTip("打开分析功能使用指南")
        tools_layout.addWidget(self.analysis_help_btn, 2, 0, 1, 2)
        
        tools_main_layout.addWidget(tools_group)
        tools_main_layout.addStretch()
        analysis_splitter.addWidget(tools_container)

        analysis_splitter.setSizes([300, 120])
        layout.addWidget(analysis_splitter)
        
        return tab

    def _create_compute_tab(self, parent_window) -> QWidget:
        tab = QWidget(); main_layout = QVBoxLayout(tab)
        
        compute_group = QGroupBox("派生变量计算 (数据库)"); custom_layout = QVBoxLayout(compute_group)
        info_label = QLabel("在此定义新的变量，计算结果将作为<b>新的一列</b>永久保存在数据库中。"); info_label.setWordWrap(True); custom_layout.addWidget(info_label)
        
        form_layout = QGridLayout()
        form_layout.addWidget(QLabel("新变量名:"), 0, 0)
        self.new_variable_name_edit = QLineEdit(); self.new_variable_name_edit.setPlaceholderText("例: velocity_magnitude")
        form_layout.addWidget(self.new_variable_name_edit, 0, 1)
        
        form_layout.addWidget(QLabel("计算公式:"), 1, 0)
        self.new_variable_formula_edit = QLineEdit(); self.new_variable_formula_edit.setPlaceholderText("例: sqrt(u*u + v*v)")
        form_layout.addWidget(self.new_variable_formula_edit, 1, 1)
        custom_layout.addLayout(form_layout)
        
        note_label = QLabel("<b>注意:</b> 公式必须使用 <b>SQLite兼容</b> 的语法和函数 (如 `sqrt`, `sin`, `cos` 等)。"); note_label.setWordWrap(True)
        note_label.setStyleSheet("color: #555; font-size: 9pt;")
        custom_layout.addWidget(note_label)

        self.compute_and_add_btn = QPushButton("计算并添加列到数据库"); self.compute_and_add_btn.setEnabled(False)
        custom_btn_layout = QHBoxLayout(); custom_btn_layout.addStretch(); custom_btn_layout.addWidget(self.compute_and_add_btn); custom_layout.addLayout(custom_btn_layout)
        
        main_layout.addWidget(compute_group)
        main_layout.addStretch()
        tab.setLayout(main_layout)
        return tab
        
    def _create_statistics_tab(self, parent_window) -> QWidget:
        tab = QWidget(); main_layout = QVBoxLayout(tab)
        basic_group = QGroupBox("基础统计"); basic_layout = QVBoxLayout(basic_group)
        info_label = QLabel("基础统计数据在数据导入时自动计算并存储在数据库中。"); info_label.setWordWrap(True); basic_layout.addWidget(info_label)
        self.recalc_basic_stats_btn = QPushButton("重新计算所有基础统计")
        self.recalc_basic_stats_btn.setToolTip("在数据损坏或需要强制刷新时使用。")
        self.export_stats_btn = QPushButton("一键导出统计结果"); self.export_stats_btn.setEnabled(False)
        h_layout = QHBoxLayout()
        h_layout.addWidget(self.recalc_basic_stats_btn)
        h_layout.addWidget(self.export_stats_btn)
        basic_layout.addLayout(h_layout)
        main_layout.addWidget(basic_group)
        
        custom_group = QGroupBox("自定义常量计算"); custom_layout = QVBoxLayout(custom_group)
        custom_header_layout = QHBoxLayout(); custom_info = QLabel("在此定义新的全局常量，每行一个。定义将被永久保存。"); custom_info.setTextFormat(Qt.TextFormat.RichText); custom_info.setWordWrap(True)
        custom_header_layout.addWidget(custom_info, 1); 
        self.custom_stats_help_action = QAction() # Action for menu/toolbar
        custom_help_btn = QPushButton("?"); custom_help_btn.setFixedSize(25, 25); custom_help_btn.clicked.connect(lambda: parent_window._show_help("custom_stats"))
        custom_header_layout.addWidget(custom_help_btn); custom_layout.addLayout(custom_header_layout)
        
        self.custom_stats_input = QTextEdit(); self.custom_stats_input.setFont(QFont("Courier New", 9)); self.custom_stats_input.setPlaceholderText("tke_global = mean(0.5 * (u**2 + v**2))\navg_vorticity = mean(curl(u, v))")
        self.custom_stats_input.setFixedHeight(120); custom_layout.addWidget(self.custom_stats_input)
        self.save_and_calc_custom_stats_btn = QPushButton("保存定义并重新计算"); self.save_and_calc_custom_stats_btn.setEnabled(False); custom_btn_layout = QHBoxLayout(); custom_btn_layout.addStretch(); custom_btn_layout.addWidget(self.save_and_calc_custom_stats_btn); custom_layout.addLayout(custom_btn_layout)
        main_layout.addWidget(custom_group)

        results_group = QGroupBox("计算结果"); results_layout = QVBoxLayout(results_group)
        self.stats_results_text = QTextEdit(); self.stats_results_text.setReadOnly(True); self.stats_results_text.setFont(QFont("Courier New", 9)); self.stats_results_text.setText("尚未计算。")
        results_layout.addWidget(self.stats_results_text); main_layout.addWidget(results_group); main_layout.addStretch(); return tab

    def _create_datamanagement_tab(self, parent_window) -> QWidget:
        tab = QWidget()
        layout = QVBoxLayout(tab)
        
        filter_group = QGroupBox("全局数据过滤器"); filter_layout = QVBoxLayout(filter_group)
        filter_help_layout = QHBoxLayout()
        filter_help_layout.addWidget(QLabel("对此数据集应用SQL筛选条件。"), 1)
        dm_help_btn = QPushButton("?"); dm_help_btn.setFixedSize(25,25); dm_help_btn.setToolTip("打开数据管理与过滤帮助")
        dm_help_btn.clicked.connect(lambda: parent_window._show_help("analysis"))
        filter_help_layout.addWidget(dm_help_btn)
        filter_layout.addLayout(filter_help_layout)
        
        self.filter_enabled_checkbox = QCheckBox("启用全局数据过滤器")
        filter_layout.addWidget(self.filter_enabled_checkbox)
        filter_hbox = QHBoxLayout()
        self.filter_text_edit = QLineEdit(); self.filter_text_edit.setPlaceholderText("SQL WHERE 子句, e.g., p > 1000")
        self.apply_filter_btn = QPushButton("应用")
        filter_hbox.addWidget(self.filter_text_edit)
        filter_hbox.addWidget(self.apply_filter_btn)
        filter_layout.addLayout(filter_hbox)
        layout.addWidget(filter_group)
        
        export_group = QGroupBox("数据导出")
        export_layout = QVBoxLayout(export_group)
        info_label = QLabel("将当前数据集（可应用全局过滤器）导出为单个CSV文件。")
        info_label.setWordWrap(True)
        export_layout.addWidget(info_label)
        self.export_data_csv_btn = QPushButton("导出数据到 CSV...")
        export_layout.addWidget(self.export_data_csv_btn)
        layout.addWidget(export_group)
        
        db_group = QGroupBox("数据库维护")
        db_layout = QVBoxLayout(db_group)
        self.db_info_label = QLabel("路径: N/A\n大小: 0.00 MB")
        db_layout.addWidget(self.db_info_label)
        self.compact_db_btn = QPushButton("压缩优化数据库")
        self.compact_db_btn.setToolTip("执行VACUUM命令，可减小文件体积并提升性能。")
        db_layout.addWidget(self.compact_db_btn)
        layout.addWidget(db_group)

        layout.addStretch()
        return tab

    def _create_export_tab(self, parent_window) -> QWidget:
        tab = QWidget(); layout = QVBoxLayout(tab)
        cfg_group = QGroupBox("设置管理"); cfg_layout = QGridLayout(cfg_group)
        cfg_layout.addWidget(QLabel("配置文件:"), 0, 0); self.config_combo = QComboBox(); cfg_layout.addWidget(self.config_combo, 0, 1, 1, 2)
        btn_layout = QHBoxLayout(); self.save_config_btn = QPushButton("保存"); self.save_config_as_btn = QPushButton("另存为..."); btn_layout.addWidget(self.save_config_btn); btn_layout.addWidget(self.save_config_as_btn); cfg_layout.addLayout(btn_layout, 1, 1, 1, 2)
        self.config_status_label = QLabel(""); self.config_status_label.setStyleSheet("color: orange;"); cfg_layout.addWidget(self.config_status_label, 2, 0, 1, 3); layout.addWidget(cfg_group)

        export_group = QGroupBox("导出"); export_layout = QGridLayout(export_group)
        export_layout.addWidget(QLabel("分辨率(DPI):"), 0, 0); self.export_dpi = QSpinBox(); self.export_dpi.setRange(100, 1200); self.export_dpi.setValue(300); export_layout.addWidget(self.export_dpi, 0, 1)
        self.export_img_btn = QPushButton("保存当前帧图片"); export_layout.addWidget(self.export_img_btn, 1, 0, 1, 2)
        export_layout.addWidget(QLabel("帧率(FPS):"), 2, 0); self.video_fps = QSpinBox(); self.video_fps.setRange(1, 60); self.video_fps.setValue(15); export_layout.addWidget(self.video_fps, 2, 1)
        export_layout.addWidget(QLabel("起始帧:"), 3, 0); self.video_start_frame = QSpinBox(); self.video_start_frame.setMinimum(0); export_layout.addWidget(self.video_start_frame, 3, 1)
        export_layout.addWidget(QLabel("结束帧:"), 4, 0); self.video_end_frame = QSpinBox(); self.video_end_frame.setMinimum(0); export_layout.addWidget(self.video_end_frame, 4, 1)
        export_layout.addWidget(QLabel("渲染网格:"), 5, 0); grid_res_layout = QHBoxLayout()
        self.video_grid_w = QSpinBox(); self.video_grid_w.setRange(50, 2000); self.video_grid_w.setValue(300); grid_res_layout.addWidget(self.video_grid_w)
        grid_res_layout.addWidget(QLabel("x")); self.video_grid_h = QSpinBox(); self.video_grid_h.setRange(50, 2000); self.video_grid_h.setValue(300); grid_res_layout.addWidget(self.video_grid_h)
        export_layout.addLayout(grid_res_layout, 5, 1); self.export_vid_btn = QPushButton("导出视频"); export_layout.addWidget(self.export_vid_btn, 6, 0, 1, 2)
        self.batch_export_btn = QPushButton("批量视频导出..."); export_layout.addWidget(self.batch_export_btn, 7, 0, 1, 2); layout.addWidget(export_group)
        
        perf_group = QGroupBox("性能"); perf_layout = QVBoxLayout(perf_group); self.gpu_checkbox = QCheckBox("启用GPU加速 (需NVIDIA/CuPy)")
        perf_layout.addWidget(self.gpu_checkbox); cache_layout = QHBoxLayout(); cache_layout.addWidget(QLabel("内存缓存:"))
        self.cache_size_spinbox = QSpinBox(); self.cache_size_spinbox.setRange(10, 2000); self.cache_size_spinbox.setValue(100); cache_layout.addWidget(self.cache_size_spinbox)
        self.apply_cache_btn = QPushButton("应用"); cache_layout.addWidget(self.apply_cache_btn); perf_layout.addLayout(cache_layout); layout.addWidget(perf_group); layout.addStretch(); return tab

    def _create_playback_group(self) -> QGroupBox:
        group = QGroupBox("播放控制"); layout = QVBoxLayout(group); info_layout = QHBoxLayout(); self.frame_info_label = QLabel("帧: 0/0")
        info_layout.addWidget(self.frame_info_label); info_layout.addStretch(); self.timestamp_label = QLabel("时间戳: 0.0"); info_layout.addWidget(self.timestamp_label); layout.addLayout(info_layout)
        
        self.playback_widget = QWidget()
        playback_layout = QVBoxLayout(self.playback_widget)
        playback_layout.setContentsMargins(0,0,0,0)
        self.time_slider = QSlider(Qt.Orientation.Horizontal); self.time_slider.setMinimum(0); playback_layout.addWidget(self.time_slider)
        btns_layout = QHBoxLayout(); self.play_button = QPushButton("播放"); btns_layout.addWidget(self.play_button); self.prev_btn = QPushButton("<<"); btns_layout.addWidget(self.prev_btn)
        self.next_btn = QPushButton(">>"); btns_layout.addWidget(self.next_btn); self.refresh_button = QPushButton("立即刷新"); btns_layout.addWidget(self.refresh_button); btns_layout.addSpacing(20)
        btns_layout.addWidget(QLabel("跳帧:")); self.frame_skip_spinbox = QSpinBox(); self.frame_skip_spinbox.setRange(1, 100); self.frame_skip_spinbox.setValue(1); btns_layout.addWidget(self.frame_skip_spinbox)
        playback_layout.addLayout(btns_layout)
        layout.addWidget(self.playback_widget)
        return group

    def _create_path_group(self) -> QGroupBox:
        group = QGroupBox("路径设置"); layout = QGridLayout(group)
        layout.addWidget(QLabel("项目目录:"), 0, 0); self.data_dir_line_edit = QLineEdit(); self.data_dir_line_edit.setReadOnly(True); layout.addWidget(self.data_dir_line_edit, 0, 1)
        self.change_data_dir_btn = QPushButton("..."); layout.addWidget(self.change_data_dir_btn, 0, 2)
        layout.addWidget(QLabel("输出目录:"), 1, 0); self.output_dir_line_edit = QLineEdit(); self.output_dir_line_edit.setReadOnly(True); layout.addWidget(self.output_dir_line_edit, 1, 1)
        self.change_output_dir_btn = QPushButton("..."); layout.addWidget(self.change_output_dir_btn, 1, 2); return group
    
    def _create_menu_bar(self, main_window: QMainWindow):
        menubar = main_window.menuBar()
        file_menu = menubar.addMenu('文件(&F)'); self.open_data_dir_action = QAction('设置项目目录...', main_window); self.set_output_dir_action = QAction('设置输出目录...', main_window)
        self.reload_action = QAction('重新导入数据', main_window); self.reload_action.setShortcut('Ctrl+R'); self.save_config_action = QAction('保存设置', main_window); self.save_config_action.setShortcut('Ctrl+S')
        self.save_config_as_action = QAction('设置另存为...', main_window); self.save_config_as_action.setShortcut('Ctrl+Shift+S'); self.new_config_action = QAction('新建设置...', main_window); self.new_config_action.setShortcut('Ctrl+N')
        self.exit_action = QAction('退出', main_window); self.exit_action.setShortcut('Ctrl+Q')
        file_menu.addAction(self.open_data_dir_action); file_menu.addAction(self.set_output_dir_action); file_menu.addAction(self.reload_action); file_menu.addSeparator()
        file_menu.addAction(self.save_config_action); file_menu.addAction(self.save_config_as_action); file_menu.addAction(self.new_config_action); file_menu.addSeparator(); file_menu.addAction(self.exit_action)
        
        view_menu = menubar.addMenu('视图(&V)'); self.reset_view_action = QAction('重置视图', main_window); self.reset_view_action.setShortcut('Ctrl+0')
        self.toggle_panel_action = QAction('显示/隐藏控制面板', main_window); self.toggle_panel_action.setShortcut('F4'); self.toggle_panel_action.setCheckable(True); self.toggle_panel_action.setChecked(True)
        self.full_screen_action = QAction('全屏', main_window); self.full_screen_action.setShortcut('F11'); self.full_screen_action.setCheckable(True)
        view_menu.addAction(self.reset_view_action); view_menu.addSeparator(); view_menu.addAction(self.toggle_panel_action); view_menu.addAction(self.full_screen_action)
        
        help_menu = menubar.addMenu('帮助(&H)'); self.formula_help_action = QAction('公式指南', main_window); self.formula_help_action.setShortcut('F1')
        self.analysis_help_action = QAction("分析功能指南", main_window); self.analysis_help_action.setShortcut('F2')
        self.about_action = QAction('关于 InterVis', main_window)
        help_menu.addAction(self.formula_help_action); help_menu.addAction(self.analysis_help_action); help_menu.addSeparator(); help_menu.addAction(self.about_action)

    def _create_tool_bar(self, main_window: QMainWindow):
        self.toolbar = QToolBar("MainToolBar"); self.toolbar.setObjectName("MainToolBar"); main_window.addToolBar(self.toolbar)
        self.open_data_dir_action.setToolTip("选择包含CSV文件的项目目录")
        self.reload_action.setToolTip("强制从当前目录重新导入所有CSV数据 (Ctrl+R)")
        self.toolbar.addAction(self.open_data_dir_action); self.toolbar.addAction(self.reload_action); self.toolbar.addSeparator()
        self.toolbar.addAction(self.save_config_action); self.toolbar.addSeparator(); self.toolbar.addAction(self.reset_view_action)
        self.reset_view_action.setToolTip("重置缩放和平移 (Ctrl+0)")

    def _create_status_bar(self, main_window: QMainWindow):
        self.status_bar = QStatusBar(); main_window.setStatusBar(self.status_bar)
        self.cache_label = QLabel("缓存: 0/100"); self.status_bar.addPermanentWidget(self.cache_label)
        self.gpu_status_label = QLabel("GPU: 检测中..."); self.status_bar.addPermanentWidget(self.gpu_status_label)
        self.status_bar.showMessage("准备就绪")
```
--- END OF FILE ui_setup.py ---

--- START OF FILE video_exporter.py ---
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import os, logging, time, numpy as np
import tempfile
import shutil
from concurrent.futures import ThreadPoolExecutor, as_completed
from PyQt6.QtWidgets import QDialog, QVBoxLayout, QHBoxLayout, QLabel, QProgressBar, QPushButton, QTextEdit, QMessageBox
from PyQt6.QtCore import QThread, pyqtSignal, Qt

logger = logging.getLogger(__name__)

from src.visualization.headless_renderer import HeadlessPlotter

class VideoExportWorker(QThread):
    progress_updated = pyqtSignal(int, int, str)
    export_finished = pyqtSignal(bool, str)
    
    def __init__(self, dm, p_conf, fname, s_f, e_f, fps):
        super().__init__()
        self.dm, self.p_conf, self.fname, self.s_f, self.fps = dm, p_conf, fname, s_f, fps
        self.e_f = min(e_f, self.dm.get_frame_count() - 1)
        self.is_cancelled = False
        self.executor = ThreadPoolExecutor(max_workers=max(1, os.cpu_count()))
        self.temp_dir = None
        self.success = False
        self.message = ""

    def cancel(self):
        self.is_cancelled = True
        self.executor.shutdown(wait=False, cancel_futures=True)
    
    def run(self):
        self.temp_dir = tempfile.mkdtemp(prefix="intervis_export_")
        logger.info(f"为视频导出创建临时目录: {self.temp_dir}")
        
        try:
            total = self.e_f - self.s_f + 1
            if total <= 0: raise ValueError("帧范围无效。")
            
            frame_paths, futures = {}, {self.executor.submit(self._render_frame, i, self.temp_dir): i for i in range(self.s_f, self.e_f + 1)}
            
            processed_count = 0
            for future in as_completed(futures):
                if self.is_cancelled: break
                idx, result_path = futures[future], future.result()
                if result_path: frame_paths[idx] = result_path
                processed_count += 1
                self.progress_updated.emit(processed_count, total, f"已渲染 {processed_count}/{total} 帧")

            if self.is_cancelled:
                self.success, self.message = False, "导出已取消"
                self.export_finished.emit(self.success, self.message); return

            image_files = [frame_paths[i] for i in range(self.s_f, self.e_f + 1) if i in frame_paths]
            if not image_files: raise ValueError("没有成功渲染任何帧。")

            self.progress_updated.emit(total, total, "正在编码视频...")
            self._create_video(image_files, self.fname, self.fps)
            
            self.success, self.message = True, f"视频已成功导出到:\n{self.fname}"
            self.export_finished.emit(self.success, self.message)

        except Exception as e:
            logger.error(f"视频导出失败: {e}", exc_info=True)
            self.success, self.message = False, f"导出失败: {e}"
            self.export_finished.emit(self.success, self.message)
        finally:
            self.executor.shutdown(wait=True)
            if self.temp_dir and os.path.exists(self.temp_dir):
                shutil.rmtree(self.temp_dir, ignore_errors=True)

    def _render_frame(self, idx, temp_dir):
        if self.is_cancelled: return None
        try:
            data = self.dm.get_frame_data(idx)
            if data is None: raise ValueError(f"无法为帧 {idx} 加载数据")

            frame_conf = self.p_conf.copy()
            raw_title = frame_conf.get('chart_title', '')
            if raw_title and '{' in raw_title and '}' in raw_title:
                try:
                    info = self.dm.get_frame_info(idx)
                    time_val = info.get('timestamp', float(idx)) if info else float(idx)
                    evaluated_title = raw_title.format(frame_index=idx, time=time_val)
                    frame_conf['chart_title'] = evaluated_title
                except (KeyError, ValueError, IndexError) as e:
                    logger.warning(f"格式化标题失败: '{raw_title}' with index={idx}, error: {e}. 使用原始标题。")
                    frame_conf['chart_title'] = raw_title
            
            plotter = HeadlessPlotter(frame_conf)
            image_array = plotter.render_frame(data, self.dm.get_variables())
            
            import imageio
            frame_path = os.path.join(temp_dir, f'frame_{idx:06d}.png')
            imageio.imwrite(frame_path, image_array)
            return frame_path
        except Exception as e:
            logger.error(f"渲染帧 {idx} 失败: {e}")
            return None

    def _create_video(self, image_files, fname, fps):
        try:
            import moviepy.editor as mp
            logger.info(f"使用 moviepy 从临时文件编码视频: {fname}")
            clip = mp.ImageSequenceClip(image_files, fps=fps)
            if fname.lower().endswith('.gif'): 
                clip.write_gif(fname, fps=fps, logger=None)
            else: 
                clip.write_videofile(fname, fps=fps, codec='libx264', logger='bar', threads=os.cpu_count())
            clip.close()
        except Exception as e:
            logger.warning(f"Moviepy 失败: {e}. 尝试 ImageIO...")
            try:
                import imageio
                writer_kwargs = {'fps': fps}
                if fname.lower().endswith('.mp4'):
                    writer_kwargs.update({'codec': 'libx264', 'quality': 8, 'pixelformat': 'yuv420p'})
                with imageio.get_writer(fname, **writer_kwargs) as writer:
                    for i, fpath in enumerate(image_files):
                        if self.is_cancelled: break
                        self.progress_updated.emit(i+1, len(image_files), f"ImageIO 编码帧 {i+1}/{len(image_files)}")
                        writer.append_data(imageio.v2.imread(fpath))
            except Exception as e2:
                raise RuntimeError(f"Moviepy 和 ImageIO 均导出失败: {e2}")

class VideoExportDialog(QDialog):
    def __init__(self, parent, dm, p_conf, fname, s_f, e_f, fps):
        super().__init__(parent); self.worker = None
        self._init_ui(fname, s_f, e_f, fps); self._start_export(dm, p_conf, fname, s_f, e_f, fps)
    
    def _init_ui(self, fname, s_f, e_f, fps):
        self.setWindowTitle("正在导出视频"); self.setModal(True); self.setFixedSize(450, 320)
        layout = QVBoxLayout(self)
        layout.addWidget(QLabel(f"<b>文件:</b> {os.path.basename(fname)}<br><b>帧:</b> {s_f}-{e_f}<br><b>帧率:</b> {fps}fps"))
        self.progress_bar = QProgressBar(); layout.addWidget(self.progress_bar)
        self.status_label = QLabel("准备..."); layout.addWidget(self.status_label)
        self.log_text = QTextEdit(); self.log_text.setReadOnly(True); layout.addWidget(self.log_text)
        btn_layout = QHBoxLayout(); btn_layout.addStretch()
        self.cancel_btn = QPushButton("取消"); self.cancel_btn.clicked.connect(self._cancel_export); btn_layout.addWidget(self.cancel_btn)
        self.close_btn = QPushButton("关闭"); self.close_btn.clicked.connect(self.accept); self.close_btn.setEnabled(False); btn_layout.addWidget(self.close_btn)
        layout.addLayout(btn_layout)
    
    def _start_export(self, dm, p_conf, fname, s_f, e_f, fps):
        self.worker = VideoExportWorker(dm, p_conf, fname, s_f, e_f, fps)
        self.worker.progress_updated.connect(self._on_progress_updated)
        self.worker.export_finished.connect(self._on_export_finished)
        self.worker.start(); self._log("开始并行渲染...")
    
    def _cancel_export(self):
        if self.worker and self.worker.isRunning():
            self._log("正在取消..."); self.cancel_btn.setEnabled(False); self.worker.cancel()
    
    def _on_progress_updated(self, current, total, msg):
        self.progress_bar.setMaximum(total); self.progress_bar.setValue(current); self.status_label.setText(msg)
    
    def _on_export_finished(self, success, msg):
        self.status_label.setText("完成！" if success else "失败！"); self._log(msg)
        self.cancel_btn.setEnabled(False); self.close_btn.setEnabled(True)
        if success: self.progress_bar.setValue(self.progress_bar.maximum()); QMessageBox.information(self, "成功", msg)
        else: QMessageBox.warning(self, "失败", msg)
    
    def _log(self, msg): self.log_text.append(f"[{time.strftime('%H:%M:%S')}] {msg}")
    
    def closeEvent(self, event):
        if self.worker and self.worker.isRunning():
            reply = QMessageBox.question(self, "确认", "导出正在进行，确定关闭？", QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, QMessageBox.StandardButton.No)
            if reply == QMessageBox.StandardButton.Yes: self.worker.cancel(); self.worker.wait(30000); event.accept()
            else: event.ignore()
        else: event.accept()
```
--- END OF FILE video_exporter.py ---

--- START OF FILE workers.py ---
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
后台工作线程模块
"""
import os
import json
import logging
import pandas as pd
import sqlite3
import re
import numpy as np
from typing import List, Dict, Any, Tuple
from datetime import datetime
from concurrent.futures import ProcessPoolExecutor, as_completed

from PyQt6.QtCore import QThread, pyqtSignal

from src.core.data_manager import DataManager
from src.core.statistics_calculator import StatisticsCalculator
from src.visualization.video_exporter import VideoExportWorker
from src.core.formula_engine import FormulaEngine
from src.core.computation_core import compute_gridded_field

logger = logging.getLogger(__name__)

# --- Helper function for parallel processing (must be at top level) ---
def _parallel_spatial_calc(args: Tuple) -> Tuple[int, float]:
    """
    可被序列化并由子进程执行的函数。
    """
    frame_idx, db_path, inner_expr, agg_func, base_globals = args
    # 每个子进程创建自己的 DataManager 和 FormulaEngine 实例
    dm = DataManager()
    dm.setup_project_directory(os.path.dirname(db_path))
    formula_engine = FormulaEngine()
    formula_engine.update_allowed_variables(dm.get_variables())
    formula_engine.update_custom_global_variables(base_globals)
    
    try:
        frame_data = dm.get_frame_data(frame_idx)
        if frame_data is None or frame_data.empty:
            return frame_idx, np.nan
        
        grid_comp = compute_gridded_field(frame_data, inner_expr, 'x', 'y', formula_engine, (100,100))
        result_grid = grid_comp.get('result_data')
        if result_grid is None:
            return frame_idx, np.nan
        
        with np.errstate(invalid='ignore'):
            if agg_func == 'mean': return frame_idx, np.nanmean(result_grid)
            if agg_func == 'sum': return frame_idx, np.nansum(result_grid)
            if agg_func == 'std': return frame_idx, np.nanstd(result_grid)
            if agg_func == 'var': return frame_idx, np.nanvar(result_grid)
            return frame_idx, np.nan
    except Exception as e:
        logger.error(f"子进程(帧 {frame_idx}) 计算失败: {e}")
        return frame_idx, np.nan

# --- End of helper function ---

class DatabaseImportWorker(QThread):
    """扫描CSV，导入数据库，并自动计算基础统计数据。"""
    progress = pyqtSignal(int, int, str)
    log_message = pyqtSignal(str)
    finished = pyqtSignal()
    error = pyqtSignal(str)

    def __init__(self, data_manager: DataManager, parent=None):
        super().__init__(parent)
        self.dm = data_manager
        self.is_cancelled = False
    
    def run(self):
        try:
            logger.info(f"后台数据库导入开始: 从 {self.dm.project_directory} 到 {self.dm.db_path}")
            csv_files = sorted([f for f in os.listdir(self.dm.project_directory) if f.lower().endswith('.csv')])
            if not csv_files:
                self.error.emit("目录中未找到任何CSV文件。"); return

            self.progress.emit(0, len(csv_files) + 2, f"分析 {csv_files[0]}...")
            df_sample = pd.read_csv(os.path.join(self.dm.project_directory, csv_files[0]), nrows=10)
            numeric_cols = df_sample.select_dtypes(include=np.number).columns.tolist()
            if not numeric_cols: raise ValueError("第一个CSV文件中未找到数值列。")

            conn = self.dm.get_db_connection()
            self.dm.create_database_tables(conn) # 创建元数据表
            cols_def = ", ".join([f'"{col}" REAL' for col in numeric_cols])
            conn.execute(f"CREATE TABLE timeseries_data (id INTEGER PRIMARY KEY, frame_index INTEGER NOT NULL, timestamp REAL, {cols_def});")
            conn.commit()

            for i, filename in enumerate(csv_files):
                if self.is_cancelled: break
                self.progress.emit(i + 1, len(csv_files) + 2, f"正在导入: {filename}")
                df = pd.read_csv(os.path.join(self.dm.project_directory, filename), usecols=numeric_cols, dtype=float)
                df['frame_index'] = i; df['timestamp'] = float(i)
                df.to_sql('timeseries_data', conn, if_exists='append', index=False)
            
            if self.is_cancelled: conn.close(); os.remove(self.dm.db_path); return

            self.progress.emit(len(csv_files) + 1, len(csv_files) + 2, "创建索引...")
            conn.execute("CREATE INDEX IF NOT EXISTS idx_frame ON timeseries_data (frame_index);")
            conn.commit(); conn.close()
            
            self.log_message.emit("导入完成，正在计算基础统计数据...")
            self.dm.refresh_schema_info()
            stats_worker = GlobalStatsWorker(self.dm, self.dm.get_variables())
            stats_worker.progress.connect(lambda cur, tot, msg: self.progress.emit(len(csv_files) + 2, len(csv_files) + 2, f"统计: {msg}"))
            stats_worker.error.connect(self.error.emit)
            stats_worker.finished.connect(lambda: self.finished.emit())
            stats_worker.run()

        except Exception as e:
            logger.error(f"数据库导入失败: {e}", exc_info=True)
            self.error.emit(str(e))
            if os.path.exists(self.dm.db_path):
                try: os.remove(self.dm.db_path)
                except Exception as ce: logger.error(f"清理失败的DB文件时出错: {ce}")

class DerivedVariableWorker(QThread):
    progress = pyqtSignal(int, int, str)
    finished = pyqtSignal()
    error = pyqtSignal(str)

    def __init__(self, data_manager: DataManager, new_name: str, formula: str, parent=None):
        super().__init__(parent)
        self.dm = data_manager; self.new_name = new_name; self.formula = formula

    def run(self):
        try:
            self.progress.emit(0, 3, "步骤 1/3: 修改数据库表结构...")
            conn = self.dm.get_db_connection()
            safe_name = f'"{self.new_name}"'
            conn.execute(f"ALTER TABLE timeseries_data ADD COLUMN {safe_name} REAL;")
            conn.commit()
            
            self.progress.emit(1, 3, "步骤 2/3: 批量计算新列数据...")
            update_query = f"UPDATE timeseries_data SET {safe_name} = ({self.formula});"
            logger.info(f"执行SQL更新: {update_query}")
            conn.execute(update_query)
            conn.commit(); conn.close()

            self.progress.emit(2, 3, f"步骤 3/3: 计算新变量 '{self.new_name}' 的统计数据...")
            stats_worker = GlobalStatsWorker(self.dm, [self.new_name])
            stats_worker.error.connect(lambda e: logger.error(f"计算新变量统计时出错: {e}"))
            stats_worker.run()

            self.progress.emit(3, 3, "完成！")
            self.finished.emit()

        except Exception as e:
            logger.error(f"计算派生变量 '{self.new_name}' 失败: {e}", exc_info=True)
            self.error.emit(str(e))

class BatchExportWorker(QThread):
    progress = pyqtSignal(int, int, str)
    log_message = pyqtSignal(str)
    summary_ready = pyqtSignal(str) 

    def __init__(self, config_files: List[str], data_manager: DataManager, output_dir: str, parent=None):
        super().__init__(parent); self.config_files, self.dm, self.output_dir = config_files, data_manager, output_dir; self.is_cancelled = False

    def run(self):
        successful, failed, total = 0, 0, len(self.config_files)
        for i, filepath in enumerate(self.config_files):
            if self.is_cancelled: break
            filename = os.path.basename(filepath)
            self.progress.emit(i, total, filename); self.log_message.emit(f"读取配置: {filename}")
            try:
                with open(filepath, 'r', encoding='utf-8') as f: config = json.load(f)
                export_cfg = config.get("export", {})
                p_conf = {
                    'x_axis_formula': config.get('axes',{}).get('x_formula','x'), 'y_axis_formula': config.get('axes',{}).get('y_formula','y'),
                    'chart_title': config.get('axes',{}).get('title',''), 'use_gpu': config.get('performance',{}).get('gpu',False),
                    'heatmap_config': config.get('heatmap',{}), 'contour_config': config.get('contour',{}), 'vector_config': config.get('vector',{}),
                    'analysis': config.get('analysis',{}),
                    'grid_resolution': (export_cfg.get("video_grid_w",300), export_cfg.get("video_grid_h",300)),
                    'export_dpi': export_cfg.get("dpi",300), 'global_scope': self.dm.global_stats
                }
                s_f, e_f, fps = export_cfg.get("video_start_frame",0), export_cfg.get("video_end_frame",self.dm.get_frame_count()-1), export_cfg.get("video_fps",15)
                if s_f >= e_f: raise ValueError("起始帧需小于结束帧")

                out_fname = os.path.join(self.output_dir, f"batch_{os.path.splitext(filename)[0]}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.mp4")
                self.log_message.emit(f"准备导出: {os.path.basename(out_fname)}")
                
                vid_worker = VideoExportWorker(self.dm, p_conf, out_fname, s_f, e_f, fps)
                vid_worker.progress_updated.connect(lambda cur, tot, msg: self.log_message.emit(f"  └ {msg}"))
                vid_worker.run(); vid_worker.wait()

                if vid_worker.success: self.log_message.emit(f"成功: {filename}"); successful += 1
                else: self.log_message.emit(f"失败: {filename}. 原因: {vid_worker.message}"); failed += 1
            except Exception as e: self.log_message.emit(f"处理 '{filename}' 时发生严重错误: {e}"); failed += 1
        
        self.summary_ready.emit(f"成功导出 {successful} 个视频，失败 {failed} 个。")

    def cancel(self): self.is_cancelled = True

class GlobalStatsWorker(QThread):
    progress = pyqtSignal(int, int, str)
    finished = pyqtSignal()
    error = pyqtSignal(str)

    def __init__(self, data_manager: DataManager, vars_to_calc: List[str], parent=None):
        super().__init__(parent)
        self.dm = data_manager; self.vars_to_calc = vars_to_calc
        self.calculator = StatisticsCalculator(self.dm)

    def run(self):
        try:
            queries = self.calculator.get_global_stats_queries(self.vars_to_calc)
            if not queries: self.finished.emit(); return
            
            stats_results = {}
            conn = self.dm.get_db_connection()
            total = len(queries)
            for i, (var, query) in enumerate(queries.items()):
                self.progress.emit(i + 1, total, f"变量: {var}")
                res = conn.execute(query).fetchone()
                mean, sum_val, min_val, max_val, var_val, std_val = res if res and all(r is not None for r in res) else (0,0,0,0,0,0)
                stats_results.update({f"{var}_global_mean": mean, f"{var}_global_sum": sum_val, f"{var}_global_min": min_val, f"{var}_global_max": max_val, f"{var}_global_var": var_val, f"{var}_global_std": std_val})

            conn.close()
            self.dm.save_global_stats(stats_results)
            self.finished.emit()
        except Exception as e:
            logger.error(f"全局统计计算失败: {e}", exc_info=True)
            self.error.emit(str(e))

class CustomGlobalStatsWorker(QThread):
    progress = pyqtSignal(int, int, str)
    finished = pyqtSignal()
    error = pyqtSignal(str)

    def __init__(self, data_manager: DataManager, definitions: List[str], parent=None):
        super().__init__(parent)
        self.calculator = StatisticsCalculator(data_manager)
        self.definitions, self.dm = definitions, data_manager

    def run(self):
        try:
            self.dm.load_global_stats()
            base_stats = self.dm.global_stats.copy()
            if not base_stats and any('global' in d for d in self.definitions): raise RuntimeError("计算前必须有基础统计数据。")
            
            new_stats, new_formulas = {}, {}
            
            for i, definition in enumerate(self.definitions):
                name, formula, _ = self.calculator.parse_definition(definition)
                current_globals = {**base_stats, **new_stats}

                if any(sf in formula for sf in FormulaEngine().spatial_functions):
                    result = self._calculate_spatial_stats_parallel(name, formula, current_globals, i)
                else:
                    result = self._calculate_sql_stats(definition, current_globals, i)
                
                new_stats[name], new_formulas[name] = result, formula

            self.dm.save_global_stats(new_stats)
            self.dm.custom_global_formulas.update(new_formulas)
            self.finished.emit()
            
        except Exception as e:
            logger.error(f"自定义全局常量计算失败: {e}", exc_info=True)
            self.error.emit(str(e))

    def _calculate_sql_stats(self, definition, globals, i):
        self.progress.emit(i+1, len(self.definitions), f"SQL: {definition}")
        _, _, query = self.calculator.get_custom_global_stats_query(definition, globals)
        conn = self.dm.get_db_connection()
        result = conn.execute(query).fetchone()[0]
        conn.close()
        return result

    def _calculate_spatial_stats_parallel(self, name, formula, globals, i):
        logger.info(f"并行空间运算: {formula}")
        agg_match = re.match(r'(\w+)\((.*)\)', formula)
        if not agg_match: raise ValueError("空间运算常量需含聚合函数(mean,sum等)。")
        
        agg_func, inner_expr = agg_match.groups()
        frame_count = self.dm.get_frame_count()
        frame_results = []
        
        tasks = [(idx, self.dm.db_path, inner_expr, agg_func, globals) for idx in range(frame_count)]
        
        processed_count = 0
        with ProcessPoolExecutor(max_workers=os.cpu_count()) as executor:
            future_to_frame = {executor.submit(_parallel_spatial_calc, task): task[0] for task in tasks}
            for future in as_completed(future_to_frame):
                frame_idx, result = future.result()
                if not np.isnan(result):
                    frame_results.append(result)
                processed_count += 1
                msg = f"'{name}': 并行计算帧 {processed_count}/{frame_count}"
                self.progress.emit(i * frame_count + processed_count, len(self.definitions) * frame_count, msg)

        if not frame_results: raise ValueError("未能计算出有效结果。")
        return np.mean(frame_results)

class DataExportWorker(QThread):
    """后台导出数据到CSV的线程。"""
    progress = pyqtSignal(int, int, str)
    finished = pyqtSignal()
    error = pyqtSignal(str)

    def __init__(self, data_manager, filepath, filter_clause, parent=None):
        super().__init__(parent)
        self.dm = data_manager
        self.filepath = filepath
        self.filter_clause = filter_clause.replace("AND", "", 1).strip() if filter_clause.startswith("AND") else filter_clause

    def run(self):
        try:
            conn = self.dm.get_db_connection()
            
            count_query = f"SELECT COUNT(*) FROM timeseries_data"
            if self.filter_clause: count_query += f" WHERE {self.filter_clause}"
            total_rows = conn.execute(count_query).fetchone()[0]
            if total_rows == 0: self.error.emit("没有符合过滤条件的数据可导出。"); return

            query = "SELECT * FROM timeseries_data"
            if self.filter_clause: query += f" WHERE {self.filter_clause}"
            
            logger.info(f"开始导出数据，查询: {query}")
            
            chunksize = 50000
            chunks = pd.read_sql_query(query, conn, chunksize=chunksize)
            
            is_first_chunk = True
            rows_written = 0
            for i, chunk in enumerate(chunks):
                mode = 'w' if is_first_chunk else 'a'
                header = is_first_chunk
                chunk.to_csv(self.filepath, mode=mode, header=header, index=False)
                is_first_chunk = False
                rows_written += len(chunk)
                self.progress.emit(rows_written, total_rows, f"已导出 {rows_written}/{total_rows} 行")

            conn.close()
            self.finished.emit()

        except Exception as e:
            logger.error(f"导出数据到CSV失败: {e}", exc_info=True)
            self.error.emit(str(e))
```--- END OF FILE workers.py ---