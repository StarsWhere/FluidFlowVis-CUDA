你好！我分析了你的`InterVis`项目，这是一个功能相当完善的数据可视化工具。为了使其更易于维护、扩展和理解，我进行了一系列的重构和优化。

核心重构思路如下：

1.  **责任分离 (Separation of Concerns)**: 将庞大的 `main_window.py` 拆分为多个更小、职责更单一的“处理器” (Handler) 类。例如，专门处理配置管理、统计计算、导出任务和播放控制的类。这使得每个部分的代码都更容易理解和修改。
2.  **减少代码重复 (Don't Repeat Yourself - DRY)**: `plot_widget.py`（用于实时显示）和 `headless_renderer.py`（用于视频导出）中有大量重复的插值和数据计算逻辑。我将这部分核心逻辑提取到了一个新的 `rendering_core.py` 模块中，供两者共同调用。
3.  **明确数据流**: 将统计计算的逻辑从 `DataManager` 中移出，放入一个新的 `StatisticsCalculator` 类。这让 `DataManager` 的职责更纯粹——只负责数据的读取、索引和缓存，而计算任务则由专门的计算器负责。
4.  **代码组织**:
    *   创建了新的 `src/core` 和 `src/handlers` 目录来组织这些新的模块。
    *   将 `formula_validator.py` 重命名为 `formula_engine.py`，因为它不仅验证公式，还负责执行计算，新名称更能反映其功能。

通过这些修改，项目结构变得更加清晰，逻辑更加内聚，未来添加新功能或修复问题时，你将能更快地定位到需要修改的代码。

---

### 文件修改摘要

*   **重大修改**:
    *   `main_window.py`: 大幅简化，现在作为协调器，将具体任务委托给新创建的处理器类。
    *   `data_manager.py`: 移除了统计计算逻辑，使其专注于数据I/O和缓存。
    *   `plot_widget.py`: 简化了其内部工作线程，调用共享的渲染核心。
    *   `headless_renderer.py`: 同样调用共享的渲染核心，减少了代码重复。
    *   `workers.py`: 更新了工作线程以使用新的 `StatisticsCalculator`。
    *   `main.py`: 更新了版本号。
    *   `ui_setup.py`: 更新了版本号和一处参数名。
    *   `video_exporter.py`: 更新了对 `FormulaValidator` 的调用为 `FormulaEngine`。
*   **重命名**:
    *   `formula_validator.py` -> `src/core/formula_engine.py` (类名也已更改)。
*   **新增文件**:
    *   `src/core/statistics_calculator.py`: 封装了所有统计计算逻辑。
    *   `src/core/rendering_core.py`: 封装了共享的插值和网格数据生成逻辑。
    *   `src/handlers/config_handler.py`: 处理所有与配置文件相关的操作。
    *   `src/handlers/export_handler.py`: 处理图像、视频和批量导出。
    *   `src/handlers/playback_handler.py`: 处理播放控制逻辑。
    *   `src/handlers/stats_handler.py`: 处理统计面板的交互和计算。
    *   (以及 `src/core/__init__.py` 和 `src/handlers/__init__.py` 使其成为包)。
*   **无更改的文件**:
    *   `gpu_utils.py`
    *   `help_content.py`
    *   `help_dialog.py`
    *   `logger.py`
    *   `dialogs.py`

---

以下是所有修改和新增文件的完整代码。你可以直接用这些内容覆盖你项目中的同名文件。

### 新增文件

**`src/core/__init__.py`**
```python
# 此文件为空，用于将 core 目录标记为 Python 包。
```

**`src/handlers/__init__.py`**
```python
# 此文件为空，用于将 handlers 目录标记为 Python 包。
```

**`src/core/rendering_core.py`**
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
核心渲染模块：提供共享的数据准备与插值功能
"""
import numpy as np
import logging
from scipy.interpolate import griddata
from scipy.spatial.qhull import QhullError
from typing import Dict, Any

from src.core.formula_engine import FormulaEngine
from src.utils.gpu_utils import is_gpu_available, evaluate_formula_gpu

logger = logging.getLogger(__name__)

def prepare_gridded_data(data: np.ndarray, config: Dict[str, Any], formula_engine: FormulaEngine) -> Dict[str, Any]:
    """
    根据配置，处理原始数据，执行公式计算和插值，返回可用于绘图的网格化数据。
    这是一个核心的、可被多处调用的函数。
    """
    if data is None or data.empty:
        return {}
    
    # --- 1. 准备配置和数据 ---
    processed_data = data.copy()
    
    # 从配置中获取公式
    x_formula = config.get('x_axis_formula', 'x')
    y_formula = config.get('y_axis_formula', 'y')
    heatmap_cfg = config.get('heatmap_config', {})
    contour_cfg = config.get('contour_config', {})
    vector_cfg = config.get('vector_config', {})
    use_gpu = config.get('use_gpu', False) and is_gpu_available()

    # --- 2. 坐标轴求值 ---
    try:
        x_values = formula_engine.evaluate_formula(processed_data, x_formula)
        processed_data['__x_calculated__'] = x_values
    except Exception as e:
        raise ValueError(f"X轴公式求值失败: {e}")

    try:
        y_values = formula_engine.evaluate_formula(processed_data, y_formula)
        processed_data['__y_calculated__'] = y_values
    except Exception as e:
        raise ValueError(f"Y轴公式求值失败: {e}")
        
    # --- 3. 网格与插值点定义 ---
    grid_resolution = config.get('grid_resolution', (150, 150))
    gx, gy = np.meshgrid(
        np.linspace(processed_data['__x_calculated__'].min(), processed_data['__x_calculated__'].max(), grid_resolution[0]),
        np.linspace(processed_data['__y_calculated__'].min(), processed_data['__y_calculated__'].max(), grid_resolution[1])
    )
    points = processed_data[['__x_calculated__', '__y_calculated__']].values
    
    # --- 4. 绘图数据求值 (热力图、等高线、矢量场) ---
    def get_values_from_formula(cfg, formula_key='formula'):
        formula = cfg.get(formula_key, '').strip()
        if not cfg.get('enabled') or not formula: 
            return None
        
        # 聚合函数不能在GPU上按点计算
        uses_aggregates = any(agg_func in formula for agg_func in formula_engine.allowed_aggregates)
        
        if use_gpu and not uses_aggregates:
            try:
                req_vars = formula_engine.get_used_variables(formula)
                var_data = {var: data[var].values for var in req_vars}
                combined_vars = {**formula_engine.get_all_constants_and_globals(), **var_data}
                return evaluate_formula_gpu(formula, combined_vars)
            except Exception as e:
                logger.warning(f"GPU评估公式 '{formula}' 失败，回退到CPU。错误: {e}")
                return formula_engine.evaluate_formula(data, formula)
        else:
            return formula_engine.evaluate_formula(data, formula)

    heatmap_z = get_values_from_formula(heatmap_cfg)
    contour_z = get_values_from_formula(contour_cfg)
    vector_u = get_values_from_formula(vector_cfg, 'u_formula')
    vector_v = get_values_from_formula(vector_cfg, 'v_formula')
    
    # --- 5. 插值 ---
    try:
        heatmap_data = griddata(points, heatmap_z, (gx, gy), method='linear') if heatmap_z is not None else None
        contour_data = griddata(points, contour_z, (gx, gy), method='linear') if contour_z is not None else None
        vector_u_data = griddata(points, vector_u, (gx, gy), method='linear') if vector_u is not None else None
        vector_v_data = griddata(points, vector_v, (gx, gy), method='linear') if vector_v is not None else None
    except QhullError:
        raise ValueError(
            "输入点共线或退化，无法生成2D插值网格。\n\n"
            "这通常是因为X轴和Y轴的公式相同，或公式导致所有点都落在一条直线上。"
        )
    
    # --- 6. 返回结果 ---
    return {
        'grid_x': gx, 'grid_y': gy, 
        'heatmap_data': heatmap_data, 
        'contour_data': contour_data,
        'vector_u_data': vector_u_data,
        'vector_v_data': vector_v_data
    }
```

**`src/core/statistics_calculator.py`**
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
统计计算器模块
"""
import pandas as pd
import logging
import re
import os
from typing import Optional, List, Dict

logger = logging.getLogger(__name__)

class StatisticsCalculator:
    """封装所有关于数据集的统计计算逻辑。"""
    def __init__(self, data_manager):
        self.data_manager = data_manager

    def calculate_global_stats(self, progress_callback: Optional[callable] = None) -> Dict[str, float]:
        """
        计算所有数据文件中所有数值变量的全局统计量。这是一个耗时操作。
        """
        frame_count = self.data_manager.get_frame_count()
        if frame_count == 0:
            return {}

        logger.info("开始计算全局统计数据...")
        
        variables = self.data_manager.get_variables()
        sums = {var: 0.0 for var in variables}
        sq_sums = {var: 0.0 for var in variables}
        mins = {var: float('inf') for var in variables}
        maxs = {var: float('-inf') for var in variables}
        total_points = 0
        
        for i, df in enumerate(self.data_manager.iter_dataframes(use_cols=variables)):
            try:
                current_sums = df.sum()
                current_sq_sums = (df**2).sum()
                current_mins = df.min()
                current_maxs = df.max()
                
                for var in variables:
                    sums[var] += current_sums.get(var, 0)
                    sq_sums[var] += current_sq_sums.get(var, 0)
                    mins[var] = min(mins[var], current_mins.get(var, float('inf')))
                    maxs[var] = max(maxs[var], current_maxs.get(var, float('-inf')))

                total_points += len(df)
                
                if progress_callback:
                    progress_callback(i + 1, frame_count)
            except Exception as e:
                path = self.data_manager.get_frame_info(i)['path']
                logger.error(f"处理文件 {path} 时出错: {e}")
                continue

        if total_points == 0:
            logger.warning("未能从任何文件中读取数据点，无法计算统计信息。")
            return {}

        results = {}
        for var in variables:
            if var not in sums or total_points == 0: continue
            mean = sums[var] / total_points
            var_val = (sq_sums[var] / total_points) - mean**2
            std_dev = var_val**0.5 if var_val > 0 else 0.0
            
            results[f"{var}_global_mean"] = mean
            results[f"{var}_global_sum"] = sums[var]
            results[f"{var}_global_std"] = std_dev
            results[f"{var}_global_var"] = var_val
            results[f"{var}_global_min"] = mins[var]
            results[f"{var}_global_max"] = maxs[var]

        logger.info(f"全局统计数据计算完成。共处理 {total_points} 个数据点。")
        return results

    def calculate_custom_global_stats(self, definitions: List[str], base_global_stats: Dict, progress_callback: Optional[callable]) -> Dict[str, float]:
        """
        根据用户定义计算新的全局常量。
        """
        logger.info(f"开始计算自定义全局常量: {definitions}")
        available_globals = base_global_stats.copy()
        new_stats = {}
        
        num_defs = len(definitions)
        num_files = self.data_manager.get_frame_count()
        variables = self.data_manager.get_variables()

        for def_idx, definition in enumerate(definitions):
            if '=' not in definition:
                raise ValueError(f"定义无效 (缺少 '='): {definition}")
            
            name, formula = definition.split('=', 1)
            name = name.strip()
            formula = formula.strip()
            
            if not name.isidentifier():
                raise ValueError(f"常量名称无效: '{name}'")

            match = re.fullmatch(r'\s*(\w+)\s*\((.*)\)\s*', formula)
            if not match:
                raise ValueError(f"公式格式无效 (需要 agg_func(expression)): {formula}")

            agg_func, inner_expr = match.groups()
            supported_aggs = {'mean', 'sum', 'std', 'var'}
            if agg_func not in supported_aggs:
                raise ValueError(f"不支持的全局聚合函数: {agg_func}。支持的: {supported_aggs}")
            
            processed_expr = inner_expr
            for var_name in sorted(available_globals.keys(), key=len, reverse=True):
                pattern = r'\b' + re.escape(var_name) + r'\b'
                replacement = '@' + var_name
                processed_expr = re.sub(pattern, replacement, processed_expr)
            logger.debug(f"Original expression: '{inner_expr}', Processed for eval: '{processed_expr}'")

            total_sum = 0.0
            total_sum_sq = 0.0
            total_count = 0

            for file_idx, df in enumerate(self.data_manager.iter_dataframes(use_cols=variables)):
                try:
                    expr_vals = df.eval(processed_expr, local_dict=available_globals, global_dict={})
                    
                    total_sum += expr_vals.sum()
                    if agg_func in ['std', 'var']:
                        total_sum_sq += (expr_vals**2).sum()
                    total_count += len(expr_vals)

                    if progress_callback:
                        progress_callback(def_idx * num_files + file_idx + 1, num_defs * num_files, f"正在计算 '{name}' ({file_idx+1}/{num_files})")
                except Exception as e:
                    path = self.data_manager.get_frame_info(file_idx)['path']
                    logger.error(f"Error evaluating expression '{processed_expr}' in file {path}: {e}")
                    raise RuntimeError(f"计算 '{name}' 时在文件 {os.path.basename(path)} 中出错: {e}")

            if total_count == 0:
                raise ValueError(f"计算 '{name}' 时未能处理任何数据点。")

            result = 0.0
            if agg_func == 'sum': result = total_sum
            elif agg_func == 'mean': result = total_sum / total_count
            elif agg_func in ['std', 'var']:
                mean_val = total_sum / total_count
                var_val = (total_sum_sq / total_count) - mean_val**2
                result = var_val if agg_func == 'var' else (var_val**0.5 if var_val > 0 else 0.0)

            available_globals[name] = result
            new_stats[name] = result
            logger.info(f"计算完成: {name} = {result}")

        return new_stats
```

**`src/handlers/config_handler.py`**
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
配置管理处理器
"""
import os
import json
import logging
from typing import Dict, Any, Optional

from PyQt6.QtWidgets import QFileDialog, QMessageBox, QInputDialog, QWidget
from PyQt6.QtCore import QTimer

logger = logging.getLogger(__name__)

class ConfigHandler:
    """处理所有与加载、保存和管理可视化设置文件相关的逻辑。"""
    
    def __init__(self, main_window, ui, data_manager):
        self.main_window = main_window
        self.ui = ui
        self.dm = data_manager
        self.settings = main_window.settings
        
        self.settings_dir = os.path.join(os.getcwd(), "settings")
        os.makedirs(self.settings_dir, exist_ok=True)
        
        self.config_is_dirty: bool = False
        self._is_loading_config: bool = False
        self.current_config_file: Optional[str] = None
        self._loaded_config: Optional[Dict[str, Any]] = None

    def connect_signals(self):
        """连接此处理器管理的UI组件的信号。"""
        self.ui.config_combo.currentIndexChanged.connect(self.on_config_selected)
        self.ui.save_config_btn.clicked.connect(self.save_current_config)
        self.ui.save_config_as_btn.clicked.connect(self.save_config_as)
        self.ui.new_config_action.triggered.connect(self.create_new_config)
        self.ui.save_config_action.triggered.connect(self.save_current_config)
        self.ui.save_config_as_action.triggered.connect(self.save_config_as)

        # 连接所有会影响配置的控件
        widgets_to_mark_dirty = [
            # Heatmap
            self.ui.heatmap_enabled, self.ui.heatmap_colormap, self.ui.contour_labels,
            self.ui.contour_levels, self.ui.contour_linewidth, self.ui.contour_colors,
            self.ui.chart_title_edit, self.ui.x_axis_formula, self.ui.y_axis_formula, 
            self.ui.heatmap_formula, self.ui.heatmap_vmin, self.ui.heatmap_vmax, 
            self.ui.contour_formula,
            # Vector/Streamline
            self.ui.vector_enabled, self.ui.vector_plot_type, self.ui.quiver_density_spinbox,
            self.ui.quiver_scale_spinbox, self.ui.stream_density_spinbox,
            self.ui.stream_linewidth_spinbox, self.ui.stream_color_combo,
            self.ui.vector_u_formula, self.ui.vector_v_formula,
            # Export & Performance
            self.ui.export_dpi, self.ui.video_fps, self.ui.video_start_frame, 
            self.ui.video_end_frame, self.ui.video_grid_w, self.ui.video_grid_h,
            self.ui.gpu_checkbox, self.ui.cache_size_spinbox,
            self.ui.frame_skip_spinbox
        ]

        for widget in widgets_to_mark_dirty:
            if hasattr(widget, 'toggled'):
                widget.toggled.connect(self.mark_config_as_dirty)
            elif hasattr(widget, 'currentIndexChanged'):
                widget.currentIndexChanged.connect(self.mark_config_as_dirty)
            elif hasattr(widget, 'valueChanged'):
                widget.valueChanged.connect(self.mark_config_as_dirty)
            elif hasattr(widget, 'editingFinished'):
                widget.editingFinished.connect(self.mark_config_as_dirty)

    def mark_config_as_dirty(self, *args):
        if self._is_loading_config: return
        QTimer.singleShot(50, self._check_config_dirty_status)
    
    def _check_config_dirty_status(self):
        current_config = self.get_current_config()
        if self._loaded_config != current_config:
            self.config_is_dirty = True
            current_file = os.path.basename(self.current_config_file) if self.current_config_file else "新设置"
            self.ui.config_status_label.setText(f"{current_file} (未保存)")
            self.ui.config_status_label.setStyleSheet("color: orange;")
        else:
            self.config_is_dirty = False
            current_file = os.path.basename(self.current_config_file) if self.current_config_file else "新设置"
            self.ui.config_status_label.setText(f"{current_file} (已保存)")
            self.ui.config_status_label.setStyleSheet("color: green;")

    def populate_config_combobox(self):
        self.ui.config_combo.blockSignals(True)
        current_selection = self.ui.config_combo.currentText()
        self.ui.config_combo.clear()
        
        default_config_path = os.path.join(self.settings_dir, "default.json")
        if not os.path.exists(default_config_path):
            with open(default_config_path, 'w', encoding='utf-8') as f:
                json.dump(self.get_current_config(), f, indent=4)

        config_files = sorted([f for f in os.listdir(self.settings_dir) if f.endswith('.json')])
        self.ui.config_combo.addItems(config_files)
        
        last_config = os.path.basename(self.settings.value("last_config_file", default_config_path))
        if last_config in config_files:
            self.ui.config_combo.setCurrentText(last_config)
        elif current_selection in config_files:
            self.ui.config_combo.setCurrentText(current_selection)

        self.ui.config_combo.blockSignals(False)
        self.load_config_by_name(self.ui.config_combo.currentText())

    def on_config_selected(self, index: int):
        if index < 0: return
        if self.config_is_dirty:
            reply = QMessageBox.question(self.main_window, '未保存的修改', "切换前是否保存当前修改？", QMessageBox.StandardButton.Save | QMessageBox.StandardButton.Discard | QMessageBox.StandardButton.Cancel)
            if reply == QMessageBox.StandardButton.Save: self.save_current_config()
            elif reply == QMessageBox.StandardButton.Cancel:
                self.ui.config_combo.blockSignals(True)
                if self.current_config_file:
                    self.ui.config_combo.setCurrentText(os.path.basename(self.current_config_file))
                self.ui.config_combo.blockSignals(False)
                return
        self.load_config_by_name(self.ui.config_combo.currentText())

    def load_config_by_name(self, filename: str):
        if not filename: return
        filepath = os.path.join(self.settings_dir, filename)
        if not os.path.exists(filepath): 
            logger.warning(f"尝试加载但配置文件不存在: {filepath}")
            return
        
        self._is_loading_config = True
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                config = json.load(f)
                self.apply_config(config)
            self.current_config_file = filepath
            self.settings.setValue("last_config_file", filepath)
            QTimer.singleShot(100, self._finalize_config_load)
        except Exception as e:
            QMessageBox.critical(self.main_window, "加载失败", f"无法加载或解析配置文件 '{filename}':\n{e}")
            self._is_loading_config = False

    def _finalize_config_load(self):
        self._loaded_config = self.get_current_config()
        self.config_is_dirty = False
        self._check_config_dirty_status()
        self.ui.status_bar.showMessage(f"已加载设置: {os.path.basename(self.current_config_file)}", 3000)
        self._is_loading_config = False
        self.main_window._trigger_auto_apply()

    def save_current_config(self):
        if not self.current_config_file: 
            self.save_config_as()
            return
        
        try:
            with open(self.current_config_file, 'w', encoding='utf-8') as f:
                current_config = self.get_current_config()
                json.dump(current_config, f, indent=4)
            self._loaded_config = current_config
            self.config_is_dirty = False
            self._check_config_dirty_status()
            self.ui.status_bar.showMessage(f"设置已保存到 {os.path.basename(self.current_config_file)}", 3000)
        except Exception as e:
            QMessageBox.critical(self.main_window, "保存失败", f"无法写入配置文件 '{self.current_config_file}':\n{e}")

    def save_config_as(self):
        filename, _ = QFileDialog.getSaveFileName(self.main_window, "设置另存为", self.settings_dir, "JSON Files (*.json)")
        if not filename: return
        
        self.current_config_file = filename
        self.save_current_config()
        
        self.ui.config_combo.blockSignals(True)
        config_name = os.path.basename(filename)
        if self.ui.config_combo.findText(config_name) == -1:
            self.ui.config_combo.addItem(config_name)
        self.ui.config_combo.setCurrentText(config_name)
        self.ui.config_combo.blockSignals(False)
        self.settings.setValue("last_config_file", filename)

    def create_new_config(self):
        text, ok = QInputDialog.getText(self.main_window, "新建设置", "请输入新配置文件的名称:")
        if ok and text:
            new_filename = f"{text}.json" if not text.endswith('.json') else text
            new_filepath = os.path.join(self.settings_dir, new_filename)
            if os.path.exists(new_filepath):
                if QMessageBox.question(self.main_window, "文件已存在", f"文件 '{new_filename}' 已存在。是否覆盖？") != QMessageBox.StandardButton.Yes: return

            self.current_config_file = new_filepath
            self.save_current_config()
            self.populate_config_combobox()
            self.ui.config_combo.setCurrentText(new_filename)

    def get_current_config(self) -> Dict[str, Any]:
        return {
            "version": "1.7",
            "axes": {
                "title": self.ui.chart_title_edit.text(),
                "x_formula": self.ui.x_axis_formula.text(), 
                "y_formula": self.ui.y_axis_formula.text()
            },
            "heatmap": {
                'enabled': self.ui.heatmap_enabled.isChecked(), 
                'formula': self.ui.heatmap_formula.text(), 
                'colormap': self.ui.heatmap_colormap.currentText(), 
                'vmin': self.ui.heatmap_vmin.text().strip() or None, 
                'vmax': self.ui.heatmap_vmax.text().strip() or None
            },
            "contour": {
                'enabled': self.ui.contour_enabled.isChecked(), 
                'formula': self.ui.contour_formula.text(), 
                'levels': self.ui.contour_levels.value(), 
                'colors': self.ui.contour_colors.currentText(), 
                'linewidths': self.ui.contour_linewidth.value(), 
                'show_labels': self.ui.contour_labels.isChecked()
            },
            "vector": {
                'enabled': self.ui.vector_enabled.isChecked(),
                'type': "Quiver" if self.ui.vector_plot_type.currentText().startswith("矢量图") else "Streamline",
                'u_formula': self.ui.vector_u_formula.text(),
                'v_formula': self.ui.vector_v_formula.text(),
                'quiver_options': {'density': self.ui.quiver_density_spinbox.value(), 'scale': self.ui.quiver_scale_spinbox.value()},
                'streamline_options': {'density': self.ui.stream_density_spinbox.value(), 'linewidth': self.ui.stream_linewidth_spinbox.value(), 'color_by': self.ui.stream_color_combo.currentText()}
            },
            "playback": {"frame_skip_step": self.ui.frame_skip_spinbox.value()},
            "export": {"dpi": self.ui.export_dpi.value(), "video_fps": self.ui.video_fps.value(), "video_start_frame": self.ui.video_start_frame.value(), "video_end_frame": self.ui.video_end_frame.value(), "video_grid_w": self.ui.video_grid_w.value(), "video_grid_h": self.ui.video_grid_h.value()},
            "performance": {"gpu": self.ui.gpu_checkbox.isChecked(), "cache": self.ui.cache_size_spinbox.value()}
        }

    def apply_config(self, config: Dict[str, Any]):
        all_widgets = self.ui.control_panel.findChildren(QWidget)
        for widget in all_widgets: widget.blockSignals(True)
        
        try:
            axes = config.get("axes", {}); heatmap = config.get("heatmap", {}); contour = config.get("contour", {})
            vector = config.get("vector", {}); playback = config.get("playback", {}); export = config.get("export", {}); perf = config.get("performance", {})
            
            self.ui.chart_title_edit.setText(axes.get("title", "")); self.ui.x_axis_formula.setText(axes.get("x_formula", "x")); self.ui.y_axis_formula.setText(axes.get("y_formula", "y"))
            self.ui.heatmap_enabled.setChecked(heatmap.get("enabled", True)); self.ui.heatmap_formula.setText(heatmap.get("formula", "")); self.ui.heatmap_colormap.setCurrentText(heatmap.get("colormap", "viridis")); self.ui.heatmap_vmin.setText(str(heatmap.get("vmin") or "")); self.ui.heatmap_vmax.setText(str(heatmap.get("vmax") or ""))
            self.ui.contour_enabled.setChecked(contour.get("enabled", False)); self.ui.contour_formula.setText(contour.get("formula", "")); self.ui.contour_levels.setValue(contour.get("levels", 10)); self.ui.contour_colors.setCurrentText(contour.get("colors", "black")); self.ui.contour_linewidth.setValue(contour.get("linewidths", 1.0)); self.ui.contour_labels.setChecked(contour.get("show_labels", True))
            
            q_opts = vector.get('quiver_options', {}); s_opts = vector.get('streamline_options', {})
            self.ui.vector_enabled.setChecked(vector.get("enabled", False)); self.ui.vector_plot_type.setCurrentText("矢量图 (Quiver)" if vector.get("type") == "Quiver" else "流线图 (Streamline)"); self.ui.vector_u_formula.setText(vector.get("u_formula", "")); self.ui.vector_v_formula.setText(vector.get("v_formula", ""))
            self.ui.quiver_density_spinbox.setValue(q_opts.get("density", 10)); self.ui.quiver_scale_spinbox.setValue(q_opts.get("scale", 1.0)); self.ui.stream_density_spinbox.setValue(s_opts.get("density", 1.5)); self.ui.stream_linewidth_spinbox.setValue(s_opts.get("linewidth", 1.0)); self.ui.stream_color_combo.setCurrentText(s_opts.get("color_by", "速度大小"))
            
            self.ui.frame_skip_spinbox.setValue(playback.get("frame_skip_step", 1))
            self.ui.export_dpi.setValue(export.get("dpi", 300)); self.ui.video_fps.setValue(export.get("video_fps", 15)); self.ui.video_start_frame.setValue(export.get("video_start_frame", 0)); self.ui.video_end_frame.setValue(export.get("video_end_frame", 0)); self.ui.video_grid_w.setValue(export.get("video_grid_w", 300)); self.ui.video_grid_h.setValue(export.get("video_grid_h", 300))
            if self.ui.gpu_checkbox.isEnabled(): self.ui.gpu_checkbox.setChecked(perf.get("gpu", False))
            self.ui.cache_size_spinbox.setValue(perf.get("cache", 100))
            self.dm.set_cache_size(self.ui.cache_size_spinbox.value())
        finally:
            for widget in all_widgets: widget.blockSignals(False)
            self.main_window._update_gpu_status_label()
            self.main_window._on_vector_plot_type_changed()
```

**`src/handlers/export_handler.py`**
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
导出功能处理器
"""
import os
import logging
from datetime import datetime

from PyQt6.QtWidgets import QMessageBox, QFileDialog

from src.visualization.video_exporter import VideoExportDialog
from src.ui.dialogs import BatchExportDialog
from src.core.workers import BatchExportWorker

logger = logging.getLogger(__name__)

class ExportHandler:
    """处理所有与导出图像、视频和批量任务相关的逻辑。"""

    def __init__(self, main_window, ui, data_manager, config_handler):
        self.main_window = main_window
        self.ui = ui
        self.dm = data_manager
        self.config_handler = config_handler

        self.output_dir = self.main_window.output_dir
        self.settings_dir = self.config_handler.settings_dir

        self.batch_export_dialog: Optional[BatchExportDialog] = None
        self.batch_export_worker: Optional[BatchExportWorker] = None

    def connect_signals(self):
        self.ui.export_img_btn.clicked.connect(self.export_image)
        self.ui.export_vid_btn.clicked.connect(self.export_video)
        self.ui.batch_export_btn.clicked.connect(self.start_batch_export)
        self.ui.set_output_dir_action.triggered.connect(self._change_output_directory)
        self.ui.change_output_dir_btn.clicked.connect(self._change_output_directory)

    def set_output_dir(self, directory: str):
        self.output_dir = directory
        self.ui.output_dir_line_edit.setText(self.output_dir)

    def _change_output_directory(self):
        new_dir = QFileDialog.getExistingDirectory(self.main_window, "选择输出目录", self.output_dir)
        if new_dir and new_dir != self.output_dir:
            self.set_output_dir(new_dir)
            self.main_window.settings.setValue("output_directory", new_dir)

    def export_image(self):
        fname = os.path.join(self.output_dir, f"frame_{self.main_window.current_frame_index:05d}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png")
        if self.ui.plot_widget.save_figure(fname, self.ui.export_dpi.value()):
            QMessageBox.information(self.main_window, "成功", f"图片已保存到:\n{fname}")
        else:
            QMessageBox.warning(self.main_window, "失败", "图片保存失败。")

    def export_video(self):
        s_f, e_f = self.ui.video_start_frame.value(), self.ui.video_end_frame.value()
        if s_f >= e_f:
            QMessageBox.warning(self.main_window, "参数错误", "起始帧必须小于结束帧"); return
        
        fname = os.path.join(self.output_dir, f"video_{datetime.now().strftime('%Y%m%d_%H%M%S')}.mp4")
        
        current_config = self.config_handler.get_current_config()
        
        p_conf = {
            'x_axis_formula': current_config['axes']['x_formula'], 
            'y_axis_formula': current_config['axes']['y_formula'],
            'chart_title': current_config['axes']['title'],
            'use_gpu': self.ui.gpu_checkbox.isChecked(), 
            'heatmap_config': current_config['heatmap'], 
            'contour_config': current_config['contour'],
            'vector_config': current_config.get('vector', {}),
            'export_dpi': self.ui.export_dpi.value(),
            'grid_resolution': (self.ui.video_grid_w.value(), self.ui.video_grid_h.value()),
            'global_scope': self.dm.global_stats
        }
        VideoExportDialog(self.main_window, self.dm, p_conf, fname, s_f, e_f, self.ui.video_fps.value()).exec()

    def start_batch_export(self):
        if self.dm.get_frame_count() == 0:
            QMessageBox.warning(self.main_window, "无数据", "请先加载数据再执行批量导出。"); return
            
        config_files, _ = QFileDialog.getOpenFileNames(self.main_window, "选择要批量导出的配置文件", self.settings_dir, "JSON files (*.json)")
        if not config_files: return

        self.batch_export_dialog = BatchExportDialog(self.main_window)
        self.batch_export_worker = BatchExportWorker(config_files, self.dm, self.output_dir)
        self.batch_export_worker.progress.connect(self.batch_export_dialog.update_progress)
        self.batch_export_worker.log_message.connect(self.batch_export_dialog.add_log)
        self.batch_export_worker.finished.connect(self.batch_export_dialog.on_finish)
        self.batch_export_worker.finished.connect(self._on_batch_export_finished)
        self.batch_export_dialog.show()
        self.batch_export_worker.start()

    def _on_batch_export_finished(self, summary_message: str):
        if self.batch_export_dialog and self.batch_export_dialog.isVisible():
             QMessageBox.information(self.main_window, "批量导出完成", summary_message)
        else:
             self.ui.status_bar.showMessage(summary_message, 10000)
        self.batch_export_worker = None
        self.batch_export_dialog = None
    
    def on_main_window_close(self):
        """在主窗口关闭时由主窗口调用，用于安全地停止工作线程。"""
        if self.batch_export_worker and self.batch_export_worker.isRunning():
            if QMessageBox.question(self.main_window, "确认", "批量导出正在进行，确定退出吗？") == QMessageBox.StandardButton.Yes:
                self.batch_export_worker.cancel()
                # 尝试安全地断开信号连接
                try:
                    self.batch_export_worker.progress.disconnect()
                    self.batch_export_worker.log_message.disconnect()
                    self.batch_export_worker.finished.disconnect()
                except TypeError: # 如果信号未连接会引发TypeError
                    pass
                self.batch_export_worker.wait()
                self.batch_export_worker.deleteLater()
                return True # 表示可以关闭
            else:
                return False # 表示取消关闭
        return True # 表示没有正在运行的worker，可以关闭
```

**`src/handlers/playback_handler.py`**
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
播放控制处理器
"""
import logging
from PyQt6.QtCore import QTimer

logger = logging.getLogger(__name__)

class PlaybackHandler:
    """处理与时间轴、播放、暂停、逐帧导航相关的逻辑。"""
    
    def __init__(self, main_window, ui, data_manager):
        self.main_window = main_window
        self.ui = ui
        self.dm = data_manager
        
        self.is_playing: bool = False
        self.frame_skip_step: int = 1 
        self.skipped_frames: int = 0
        
        self.play_timer = QTimer(main_window)
        self.play_timer.timeout.connect(self._on_play_timer)

    def connect_signals(self):
        self.ui.play_button.clicked.connect(self.toggle_play)
        self.ui.prev_btn.clicked.connect(self.prev_frame)
        self.ui.next_btn.clicked.connect(self.next_frame)
        self.ui.time_slider.valueChanged.connect(self.on_slider_changed)
        self.ui.frame_skip_spinbox.valueChanged.connect(self.on_frame_skip_changed)

    def on_slider_changed(self, value: int):
        if value != self.main_window.current_frame_index:
            self.main_window._load_frame(value)
    
    def on_frame_skip_changed(self, value: int):
        self.frame_skip_step = value
        self.play_timer.setInterval(50)

    def toggle_play(self):
        self.is_playing = not self.is_playing
        self.ui.play_button.setText("暂停" if self.is_playing else "播放")
        if self.is_playing:
            self.play_timer.setSingleShot(True)
            self.play_timer.start(0)
            self.ui.status_bar.showMessage("播放中...")
            # 如果是首次播放，自动将探针定位到中心
            if self.ui.plot_widget.last_mouse_coords is None and self.ui.plot_widget.current_data is not None and not self.ui.plot_widget.current_data.empty:
                x_min, x_max = self.ui.plot_widget.ax.get_xlim()
                y_min, y_max = self.ui.plot_widget.ax.get_ylim()
                center_x, center_y = (x_min + x_max) / 2, (y_min + y_max) / 2
                self.ui.plot_widget.last_mouse_coords = (center_x, center_y)
                self.ui.plot_widget.get_probe_data_at_coords(center_x, center_y)
        else:
            self.play_timer.stop()
            self.ui.status_bar.showMessage("已暂停")

    def _on_play_timer(self):
        self.play_timer.stop()
        if self.ui.plot_widget.is_busy_interpolating:
            self.skipped_frames += 1
            self.ui.status_bar.showMessage(f"渲染延迟，跳过 {self.skipped_frames} 帧...", 1000)
            if self.is_playing: self.play_timer.start()
            return
        
        self.skipped_frames = 0
        frame_count = self.dm.get_frame_count()
        if frame_count > 0:
            next_frame = (self.main_window.current_frame_index + self.frame_skip_step) % frame_count
            self.ui.time_slider.setValue(next_frame)

    def prev_frame(self):
        if self.main_window.current_frame_index > 0:
            self.ui.time_slider.setValue(self.main_window.current_frame_index - 1)
    
    def next_frame(self):
        frame_count = self.dm.get_frame_count()
        if frame_count > 0 and self.main_window.current_frame_index < frame_count - 1:
            self.ui.time_slider.setValue(self.main_window.current_frame_index + 1)

    def stop_playback(self):
        """停止播放并清理计时器。"""
        if self.is_playing:
            self.toggle_play()
        self.play_timer.stop()
```

**`src/handlers/stats_handler.py`**
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
全局统计处理器
"""
import logging
import os
from typing import Dict
from PyQt6.QtWidgets import QMessageBox, QFileDialog

from src.ui.dialogs import StatsProgressDialog
from src.core.workers import GlobalStatsWorker, CustomGlobalStatsWorker

logger = logging.getLogger(__name__)

class StatsHandler:
    """处理所有与全局统计计算、UI更新和导出相关的逻辑。"""

    def __init__(self, main_window, ui, data_manager, formula_engine):
        self.main_window = main_window
        self.ui = ui
        self.dm = data_manager
        self.formula_engine = formula_engine
        
        self.output_dir = main_window.output_dir
        self.stats_progress_dialog = None
        self.stats_worker = None
        self.custom_stats_worker = None

    def connect_signals(self):
        self.ui.calc_basic_stats_btn.clicked.connect(self.start_global_stats_calculation)
        self.ui.calc_custom_stats_btn.clicked.connect(self.start_custom_stats_calculation)
        self.ui.export_stats_btn.clicked.connect(self.export_global_stats)
        self.ui.custom_stats_help_action.triggered.connect(self.show_custom_stats_help)

    def reset_global_stats(self):
        """当数据重载时调用，重置统计信息和UI状态。"""
        self.dm.clear_global_stats()
        self.formula_engine.update_custom_global_variables({})
        self.ui.stats_results_text.setText("数据已重载，请重新计算。")
        self.ui.export_stats_btn.setEnabled(False)
        self.ui.calc_custom_stats_btn.setEnabled(False)

    def start_global_stats_calculation(self):
        if self.dm.get_frame_count() == 0: return
        self.stats_progress_dialog = StatsProgressDialog(self.main_window, "正在计算基础统计")
        self.stats_worker = GlobalStatsWorker(self.dm)
        self.stats_worker.progress.connect(self.stats_progress_dialog.update_progress)
        self.stats_worker.finished.connect(self.on_global_stats_finished)
        self.stats_worker.error.connect(self.on_global_stats_error)
        self.stats_worker.start()
        self.stats_progress_dialog.exec()

    def on_global_stats_finished(self, results: Dict[str, float]):
        self.stats_progress_dialog.accept()
        if not results:
            self.ui.stats_results_text.setText("计算完成，无结果。")
            return

        self.dm.global_stats = results
        self.update_stats_display()
        self.ui.export_stats_btn.setEnabled(True)
        self.ui.calc_custom_stats_btn.setEnabled(True)
        self.formula_engine.update_custom_global_variables(self.dm.global_stats)
        self.main_window._trigger_auto_apply() # 触发重绘以应用新变量
        QMessageBox.information(self.main_window, "计算完成", "基础统计数据已计算并可用于公式中。")

    def on_global_stats_error(self, error_msg: str):
        self.stats_progress_dialog.accept()
        QMessageBox.critical(self.main_window, "计算失败", f"计算基础统计时发生错误: \n{error_msg}")

    def start_custom_stats_calculation(self):
        definitions_text = self.ui.custom_stats_input.toPlainText().strip()
        if not definitions_text: return
        definitions = [line.strip() for line in definitions_text.split('\n') if line.strip()]
        
        self.stats_progress_dialog = StatsProgressDialog(self.main_window, "正在计算自定义常量")
        self.custom_stats_worker = CustomGlobalStatsWorker(self.dm, definitions)
        self.custom_stats_worker.progress.connect(self.stats_progress_dialog.update_progress)
        self.custom_stats_worker.finished.connect(self.on_custom_stats_finished)
        self.custom_stats_worker.error.connect(self.on_custom_stats_error)
        self.custom_stats_worker.start()
        self.stats_progress_dialog.exec()

    def on_custom_stats_finished(self, new_stats: Dict[str, float]):
        self.stats_progress_dialog.accept()
        if not new_stats:
            QMessageBox.warning(self.main_window, "计算完成", "未计算出任何新的自定义常量。"); return
        
        self.dm.global_stats.update(new_stats)
        self.update_stats_display()
        self.formula_engine.update_custom_global_variables(self.dm.global_stats)
        self.main_window._trigger_auto_apply()
        QMessageBox.information(self.main_window, "计算完成", f"成功计算了 {len(new_stats)} 个自定义常量。")

    def on_custom_stats_error(self, error_msg: str):
        self.stats_progress_dialog.accept()
        QMessageBox.critical(self.main_window, "计算失败", f"计算自定义常量时发生错误: \n{error_msg}")

    def update_stats_display(self):
        all_stats = self.dm.global_stats
        if not all_stats:
            self.ui.stats_results_text.setText("无统计结果。"); return
        
        text = "\n".join([f"{k}: {v:.6e}" for k, v in all_stats.items()])
        self.ui.stats_results_text.setText(text)

    def export_global_stats(self):
        if not self.dm.global_stats: return
        filepath, _ = QFileDialog.getSaveFileName(self.main_window, "导出统计结果", self.output_dir, "Text Files (*.txt)")
        if not filepath: return

        try:
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(self.ui.stats_results_text.toPlainText())
            QMessageBox.information(self.main_window, "导出成功", f"统计结果已保存到:\n{filepath}")
        except Exception as e:
            QMessageBox.critical(self.main_window, "导出失败", f"无法保存文件: {e}")

    def show_custom_stats_help(self):
        from src.utils.help_dialog import HelpDialog
        from src.utils.help_content import get_custom_stats_help_html
        HelpDialog(get_custom_stats_help_html(), self.main_window).exec()
```

### 修改后的文件

**`main.py`**
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
InterVis
主程序入口
"""

import sys
import os
from PyQt6.QtWidgets import QApplication, QMessageBox
from PyQt6.QtGui import QIcon

# 确保导入路径正确，这是良好的实践
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from src.main_window import MainWindow
from src.utils.logger import setup_logger

def main():
    """主函数"""
    # 设置日志
    logger = setup_logger()
    
    try:
        # 创建QApplication实例
        app = QApplication(sys.argv)
        app.setApplicationName("InterVis")
        app.setApplicationVersion("1.7-Refactored") # 更新版本号
        app.setOrganizationName("StarsWhere")
        
        # Qt6 自动处理高DPI缩放
        
        # 创建主窗口
        main_window = MainWindow()
        main_window.show()
        
        logger.info("InterVis 启动成功")
        
        # 启动事件循环
        sys.exit(app.exec())
        
    except Exception as e:
        # 捕获任何未预料到的启动错误
        logger.error(f"程序启动失败: {str(e)}", exc_info=True)
        # 尝试以图形化方式显示错误
        msg_box = QMessageBox()
        msg_box.setIcon(QMessageBox.Icon.Critical)
        msg_box.setWindowTitle("启动错误")
        msg_box.setText(f"程序启动失败，请查看日志获取详细信息。\n\n错误: {str(e)}")
        msg_box.exec()
        sys.exit(1)

if __name__ == "__main__":
    main()
```

**`main_window.py`**
```python
import os
import logging
from typing import Dict, Any, Optional

from PyQt6.QtWidgets import QMainWindow, QMessageBox, QFileDialog, QLineEdit, QMenu
from PyQt6.QtCore import Qt, QSettings, QPoint
from PyQt6.QtGui import QAction

from src.core.data_manager import DataManager
from src.core.formula_engine import FormulaEngine
from src.utils.help_dialog import HelpDialog
from src.utils.gpu_utils import is_gpu_available
from src.utils.help_content import get_formula_help_html, get_axis_title_help_html
from src.ui.ui_setup import UiMainWindow

# 导入新的处理器
from src.handlers.config_handler import ConfigHandler
from src.handlers.stats_handler import StatsHandler
from src.handlers.export_handler import ExportHandler
from src.handlers.playback_handler import PlaybackHandler

logger = logging.getLogger(__name__)

class MainWindow(QMainWindow):
    """
    应用程序的主窗口类。
    现在主要作为协调器，将大部分逻辑委托给专门的处理器(Handler)类。
    """
    
    def __init__(self):
        super().__init__()
        
        # --- 核心组件 ---
        self.settings = QSettings("StarsWhere", "InterVis")
        self.data_manager = DataManager()
        self.formula_engine = FormulaEngine()
        self.ui = UiMainWindow()

        # --- 状态变量 (仅保留真正属于主窗口的状态) ---
        self.current_frame_index: int = 0
        self._should_reset_view_after_refresh: bool = False
        
        # --- 路径管理 (由处理器管理，但主窗口需要初始值) ---
        self.data_dir = self.settings.value("data_directory", os.path.join(os.getcwd(), "data"))
        self.output_dir = self.settings.value("output_directory", os.path.join(os.getcwd(), "output"))
        os.makedirs(self.data_dir, exist_ok=True)
        os.makedirs(self.output_dir, exist_ok=True)
        
        # --- 初始化处理器 (Handlers) ---
        self.config_handler = ConfigHandler(self, self.ui, self.data_manager)
        self.stats_handler = StatsHandler(self, self.ui, self.data_manager, self.formula_engine)
        self.export_handler = ExportHandler(self, self.ui, self.data_manager, self.config_handler)
        self.playback_handler = PlaybackHandler(self, self.ui, self.data_manager)
        
        # --- 初始化 ---
        self._init_ui()
        self._connect_signals()
        self._load_settings()
        self._initialize_data()

    # region 初始化
    def _init_ui(self):
        self.ui.setup_ui(self, self.formula_engine)
        self.ui.gpu_checkbox.setEnabled(is_gpu_available())
        self.ui.data_dir_line_edit.setText(self.data_dir)
        self.ui.output_dir_line_edit.setText(self.output_dir)
        self._update_gpu_status_label()
        self._on_vector_plot_type_changed() # 初始化矢量图选项可见性

    def _connect_signals(self):
        # 连接核心组件的信号
        self.data_manager.loading_finished.connect(self._on_loading_finished)
        self.data_manager.error_occurred.connect(self._on_error)
        self.ui.plot_widget.mouse_moved.connect(self._on_mouse_moved)
        self.ui.plot_widget.probe_data_ready.connect(self._on_probe_data)
        self.ui.plot_widget.value_picked.connect(self._on_value_picked)
        self.ui.plot_widget.plot_rendered.connect(self._on_plot_rendered)
        self.ui.plot_widget.interpolation_error.connect(self._on_interpolation_error)
        
        # 连接菜单和工具栏动作
        self.ui.open_data_dir_action.triggered.connect(self._change_data_directory)
        self.ui.reload_action.triggered.connect(self._reload_data)
        self.ui.exit_action.triggered.connect(self.close)
        self.ui.reset_view_action.triggered.connect(self.ui.plot_widget.reset_view)
        self.ui.toggle_panel_action.triggered.connect(self._toggle_control_panel)
        self.ui.full_screen_action.triggered.connect(self._toggle_full_screen)
        self.ui.formula_help_action.triggered.connect(self._show_formula_help)
        self.ui.about_action.triggered.connect(self._show_about)

        # 连接由主窗口直接处理的UI控件
        self.ui.change_data_dir_btn.clicked.connect(self._change_data_directory)
        self.ui.refresh_button.clicked.connect(self._force_refresh_plot)
        self.ui.apply_cache_btn.clicked.connect(self._apply_cache_settings)
        self.ui.gpu_checkbox.toggled.connect(self._on_gpu_toggle)
        self.ui.vector_plot_type.currentIndexChanged.connect(self._on_vector_plot_type_changed)

        # 委托信号连接到各自的处理器
        self.config_handler.connect_signals()
        self.stats_handler.connect_signals()
        self.export_handler.connect_signals()
        self.playback_handler.connect_signals()

        # 连接需要自动重绘的控件
        widgets_to_connect_for_redraw = [
            self.ui.heatmap_enabled, self.ui.heatmap_colormap, self.ui.contour_labels,
            self.ui.contour_levels, self.ui.contour_linewidth, self.ui.contour_colors,
            self.ui.vector_enabled, self.ui.vector_plot_type, self.ui.quiver_density_spinbox,
            self.ui.quiver_scale_spinbox, self.ui.stream_density_spinbox,
            self.ui.stream_linewidth_spinbox, self.ui.stream_color_combo,
            self.ui.chart_title_edit, self.ui.x_axis_formula, self.ui.y_axis_formula, 
            self.ui.heatmap_formula, self.ui.heatmap_vmin, self.ui.heatmap_vmax, 
            self.ui.contour_formula, self.ui.vector_u_formula, self.ui.vector_v_formula
        ]
        for widget in widgets_to_connect_for_redraw:
            if hasattr(widget, 'toggled'): widget.toggled.connect(self._trigger_auto_apply)
            elif hasattr(widget, 'currentIndexChanged'): widget.currentIndexChanged.connect(self._trigger_auto_apply)
            elif hasattr(widget, 'valueChanged'): widget.valueChanged.connect(self._trigger_auto_apply)
            elif hasattr(widget, 'editingFinished'): widget.editingFinished.connect(self._trigger_auto_apply)

    def _trigger_auto_apply(self, *args):
        """当任何可视化设置改变时，自动应用并重绘。"""
        if self.config_handler._is_loading_config: return
        if self.data_manager.get_frame_count() > 0:
            self._should_reset_view_after_refresh = True
            self._apply_visualization_settings()
        # 标记配置为脏已由ConfigHandler处理
    # endregion

    # region 信号槽实现 (主窗口保留部分)
    def _on_loading_finished(self, success: bool, message: str):
        self.ui.status_bar.showMessage(message, 5000)
        if success:
            frame_count = self.data_manager.get_frame_count()
            if frame_count > 0:
                self.formula_engine.update_allowed_variables(self.data_manager.get_variables())
                self.ui.time_slider.setMaximum(frame_count - 1)
                self.ui.video_start_frame.setMaximum(frame_count - 1)
                self.ui.video_end_frame.setMaximum(frame_count - 1)
                self.ui.video_end_frame.setValue(frame_count - 1)
                self.config_handler.populate_config_combobox() # 由ConfigHandler处理
                self.ui.calc_basic_stats_btn.setEnabled(True)
            else:
                QMessageBox.warning(self, "数据为空", "指定的数据目录中没有找到有效的CSV文件。")
                self.ui.calc_basic_stats_btn.setEnabled(False)
        else:
            QMessageBox.critical(self, "错误", f"无法初始化数据管理器: {message}")
            self.ui.calc_basic_stats_btn.setEnabled(False)

    def _on_interpolation_error(self, message: str):
        QMessageBox.critical(self, "可视化错误", f"无法渲染图形，公式可能存在问题。\n\n错误详情:\n{message}")

    def _on_error(self, message: str):
        self.ui.status_bar.showMessage(f"错误: {message}", 5000)
        QMessageBox.critical(self, "发生错误", message)

    def _on_mouse_moved(self, x: float, y: float):
        self.ui.probe_coord_label.setText(f"({x:.3e}, {y:.3e})")

    def _on_probe_data(self, probe_data: dict):
        try:
            lines = [f"{'变量名':<16s} {'数值'}", "---------------------------"]
            lines.extend([f"{k:<16s} {v:12.6e}" for k, v in probe_data['variables'].items()])
            self.ui.probe_text.setPlainText("\n".join(lines))
        except Exception as e:
            logger.debug(f"更新探针数据显示失败: {e}")

    def _on_value_picked(self, mode: str, value: float):
        target_widget = self.ui.heatmap_vmin if mode == 'vmin' else self.ui.heatmap_vmax
        target_widget.setText(f"{value:.4e}")
        self._trigger_auto_apply()

    def _on_plot_rendered(self):
        """图表渲染完成后调用。"""
        if self.playback_handler.is_playing:
            self.playback_handler.play_timer.start() # 委托给PlaybackHandler
        
        if self._should_reset_view_after_refresh:
            self.ui.plot_widget.reset_view()
            self._should_reset_view_after_refresh = False
            logger.info("图表视图已重置。")

    def _on_gpu_toggle(self, is_on):
        self.ui.plot_widget.set_config(use_gpu=is_on)
        self._update_gpu_status_label()
        self._trigger_auto_apply()

    def _on_vector_plot_type_changed(self, *args):
        is_quiver = self.ui.vector_plot_type.currentText().startswith("矢量图")
        self.ui.quiver_options_group.setVisible(is_quiver)
        self.ui.streamline_options_group.setVisible(not is_quiver)
        self._trigger_auto_apply()
    # endregion
    
    # region 核心逻辑
    def _initialize_data(self):
        self.ui.status_bar.showMessage(f"扫描目录: {self.data_dir}...")
        self.data_manager.initialize(self.data_dir)

    def _load_frame(self, frame_index: int):
        if not (0 <= frame_index < self.data_manager.get_frame_count()): return
        data = self.data_manager.get_frame_data(frame_index)
        if data is not None:
            self.current_frame_index = frame_index
            self.ui.plot_widget.update_data(data)
            self._update_frame_info()
            if self.ui.plot_widget.last_mouse_coords:
                x, y = self.ui.plot_widget.last_mouse_coords
                self.ui.plot_widget.get_probe_data_at_coords(x, y)

    def _update_frame_info(self):
        fc = self.data_manager.get_frame_count()
        self.ui.frame_info_label.setText(f"帧: {self.current_frame_index + 1}/{fc}")
        info = self.data_manager.get_frame_info(self.current_frame_index)
        if info: self.ui.timestamp_label.setText(f"时间戳: {info['timestamp']}")
        cache = self.data_manager.get_cache_info()
        self.ui.cache_label.setText(f"缓存: {cache['size']}/{cache['max_size']}")

    def _force_refresh_plot(self):
        self._should_reset_view_after_refresh = True
        self._apply_visualization_settings()
        logger.info("图表已手动刷新。")

    def _apply_visualization_settings(self):
        if self.data_manager.get_frame_count() == 0: return

        # 从ConfigHandler获取当前配置字典
        config = self.config_handler.get_current_config()
        
        # 验证公式
        def check_formula(formula, name):
            if formula and not self.formula_engine.validate(formula):
                QMessageBox.warning(self, "公式错误", f"{name}公式无效: '{formula}'")
                return False
            return True

        if not check_formula(config['axes']['x_formula'], "X轴"): return
        if not check_formula(config['axes']['y_formula'], "Y轴"): return
        if not check_formula(config['heatmap']['formula'], "热力图"): return
        if not check_formula(config['contour']['formula'], "等高线"): return
        if not check_formula(config['vector']['u_formula'], "矢量U"): return
        if not check_formula(config['vector']['v_formula'], "矢量V"): return
        
        # 应用配置到PlotWidget
        self.ui.plot_widget.set_config(
            heatmap_config=config['heatmap'],
            contour_config=config['contour'],
            vector_config=config['vector'],
            x_axis_formula=config['axes']['x_formula'] or 'x',
            y_axis_formula=config['axes']['y_formula'] or 'y',
            chart_title=config['axes']['title']
        )
        
        self._load_frame(self.current_frame_index)
        self.ui.status_bar.showMessage("可视化设置已更新", 2000)
    # endregion

    # region 菜单与文件操作
    def _show_formula_help(self, help_type: str = "formula"):
        if help_type == "axis_title":
            html_content = get_axis_title_help_html()
            title = "坐标轴与标题指南"
        else: # "formula"
            html_content = get_formula_help_html(
                base_variables=self.data_manager.get_variables(),
                custom_global_variables=self.formula_engine.custom_global_variables,
                science_constants=self.formula_engine.science_constants
            )
            title = "公式语法说明"
        HelpDialog(html_content, self).exec()
        
    def _show_about(self): 
        QMessageBox.about(self, "关于 InterVis", 
                          "<h2>InterVis v1.7</h2>"
                          "<p>作者: StarsWhere</p>"
                          "<p>一个使用PyQt6和Matplotlib构建的交互式数据可视化工具。</p>"
                          "<p><b>v1.7 (Refactored) 更新:</b></p>"
                          "<ul>"
                          "<li>重构项目结构，提高可维护性。</li>"
                          "<li>分离UI逻辑到多个独立的处理器(Handler)中。</li>"
                          "<li>减少核心模块间的代码重复。</li>"
                          "<li>优化了数据流和职责划分。</li>"
                          "</ul>")
    
    def _reload_data(self):
        if self.playback_handler.is_playing: self.playback_handler.toggle_play()
        self.stats_handler.reset_global_stats()
        self.data_manager.clear_all()
        self._initialize_data()

    def _change_data_directory(self):
        new_dir = QFileDialog.getExistingDirectory(self, "选择数据目录", self.data_dir)
        if new_dir and new_dir != self.data_dir:
            self.data_dir = new_dir
            self.ui.data_dir_line_edit.setText(self.data_dir)
            self._reload_data()
            
    def _toggle_control_panel(self, checked):
        self.ui.control_panel.setVisible(checked)

    def _toggle_full_screen(self, checked):
        if checked: self.showFullScreen()
        else: self.showNormal()
            
    def _apply_cache_settings(self): 
        self.data_manager.set_cache_size(self.ui.cache_size_spinbox.value())
        self._update_frame_info()
    # endregion

    # region 程序设置与关闭
    def _load_settings(self):
        self.restoreGeometry(self.settings.value("geometry", self.saveGeometry()))
        self.restoreState(self.settings.value("windowState", self.saveState()))
        panel_visible = self.settings.value("panel_visible", True, type=bool)
        self.ui.control_panel.setVisible(panel_visible)
        self.ui.toggle_panel_action.setChecked(panel_visible)
        self.export_handler.set_output_dir(self.output_dir)
        self._update_gpu_status_label()

    def _save_settings(self):
        self.settings.setValue("geometry", self.saveGeometry())
        self.settings.setValue("windowState", self.saveState())
        self.settings.setValue("data_directory", self.data_dir)
        self.settings.setValue("output_directory", self.export_handler.output_dir)
        self.settings.setValue("panel_visible", self.ui.control_panel.isVisible())
        if self.config_handler.current_config_file:
            self.settings.setValue("last_config_file", self.config_handler.current_config_file)

    def closeEvent(self, event):
        # 委托给ExportHandler检查是否有正在运行的导出任务
        if not self.export_handler.on_main_window_close():
            event.ignore()
            return

        if self.config_handler.config_is_dirty:
            reply = QMessageBox.question(self, '未保存的修改', "退出前是否保存当前修改？", QMessageBox.StandardButton.Save | QMessageBox.StandardButton.Discard | QMessageBox.StandardButton.Cancel)
            if reply == QMessageBox.StandardButton.Save: self.config_handler.save_current_config()
            elif reply == QMessageBox.StandardButton.Cancel: event.ignore(); return

        self._save_settings()
        self.playback_handler.stop_playback()
        if self.ui.plot_widget.thread_pool:
            self.ui.plot_widget.thread_pool.clear()
            self.ui.plot_widget.thread_pool.waitForDone()
        logger.info("应用程序正常关闭")
        super().closeEvent(event)
    # endregion

    # region 辅助方法
    def _update_gpu_status_label(self):
        if is_gpu_available():
            status, color = ("GPU: 启用", "green") if self.ui.gpu_checkbox.isChecked() else ("GPU: 可用", "orange")
        else:
            status, color = ("GPU: 不可用", "red")
        self.ui.gpu_status_label.setText(status)
        self.ui.gpu_status_label.setStyleSheet(f"color: {color};")

    def _show_variable_menu(self, line_edit: QLineEdit, position: QPoint):
        menu = QMenu(self)
        var_menu = menu.addMenu("数据变量")
        for var in sorted(self.data_manager.get_variables()):
            var_menu.addAction(var).triggered.connect(lambda checked=False, v=var: line_edit.insert(f" {v} "))
        
        if self.formula_engine.custom_global_variables:
            global_menu = menu.addMenu("全局常量")
            for g_var in sorted(self.formula_engine.custom_global_variables.keys()):
                global_menu.addAction(g_var).triggered.connect(lambda checked=False, v=g_var: line_edit.insert(f" {v} "))

        if self.formula_engine.science_constants:
            const_menu = menu.addMenu("科学常数")
            for const in sorted(self.formula_engine.science_constants.keys()):
                const_menu.addAction(const).triggered.connect(lambda checked=False, v=const: line_edit.insert(f" {v} "))
        
        if not menu.actions(): menu.addAction("无可用变量").setEnabled(False)
        menu.exec(position)
    # endregion
```

**`headless_renderer.py`**
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
无头渲染器，用于在非GUI线程中安全地生成Matplotlib图像。
"""
import numpy as np
import pandas as pd
import logging
from typing import Dict, Any, List

from matplotlib.figure import Figure
from matplotlib.backends.backend_agg import FigureCanvasAgg
import matplotlib.ticker as ticker

from src.core.rendering_core import prepare_gridded_data
from src.core.formula_engine import FormulaEngine

logger = logging.getLogger(__name__)

class HeadlessPlotter:
    """
    一个纯粹的、非GUI的绘图类，用于在后台线程中生成图像。
    它不继承QWidget，因此是线程安全的。
    """
    def __init__(self, plot_config: Dict[str, Any]):
        self.config = plot_config
        self.formula_engine = FormulaEngine()
        self.grid_resolution = self.config.get('grid_resolution', (150, 150))
        # 将全局作用域更新到公式引擎中
        self.formula_engine.update_custom_global_variables(self.config.get('global_scope', {}))

    def render_frame(self, data: pd.DataFrame, all_vars: List[str]) -> np.ndarray:
        """
        接收单帧数据和配置，返回一个代表渲染图像的NumPy数组。
        """
        # --- 1. 数据准备与插值 (调用核心模块) ---
        self.formula_engine.update_allowed_variables(all_vars)

        try:
            # 构建传递给核心渲染模块的配置
            render_config = {
                'x_axis_formula': self.config.get('x_axis_formula', 'x'),
                'y_axis_formula': self.config.get('y_axis_formula', 'y'),
                'heatmap_config': self.config.get('heatmap_config', {}),
                'contour_config': self.config.get('contour_config', {}),
                'vector_config': self.config.get('vector_config', {}),
                'use_gpu': self.config.get('use_gpu', False),
                'grid_resolution': self.grid_resolution
            }
            interpolated_results = prepare_gridded_data(data, render_config, self.formula_engine)
        except Exception as e:
            logger.error(f"无头渲染器数据准备失败: {e}")
            raise # 重新引发异常，让调用者处理

        # --- 2. Matplotlib绘图 ---
        gx = interpolated_results.get('grid_x')
        gy = interpolated_results.get('grid_y')
        if gx is None or gy is None:
            raise ValueError("网格坐标(gx, gy)未生成，无法绘图。")

        dpi = self.config.get('export_dpi', 300)
        fig = Figure(figsize=(12, 8), dpi=dpi, tight_layout=True)
        ax = fig.add_subplot(111)
        colorbar_obj = None
        
        # 提取配置用于绘图
        heatmap_cfg = self.config.get('heatmap_config', {})
        contour_cfg = self.config.get('contour_config', {})
        vector_cfg = self.config.get('vector_config', {})

        # 绘制热力图
        heatmap_data = interpolated_results.get('heatmap_data')
        if heatmap_cfg.get('enabled') and heatmap_data is not None and not np.all(np.isnan(heatmap_data)):
            vmin_str, vmax_str = heatmap_cfg.get('vmin'), heatmap_cfg.get('vmax')
            vmin = float(vmin_str) if vmin_str is not None and str(vmin_str).strip() != '' else None
            vmax = float(vmax_str) if vmax_str is not None and str(vmax_str).strip() != '' else None
            
            valid_data = heatmap_data[~np.isnan(heatmap_data)]
            if valid_data.size > 0:
                if vmin is None: vmin = np.min(valid_data)
                if vmax is None: vmax = np.max(valid_data)

            pcm = ax.pcolormesh(gx, gy, heatmap_data, 
                                cmap=heatmap_cfg.get('colormap', 'viridis'), 
                                vmin=vmin, vmax=vmax, shading='gouraud')
            colorbar_obj = fig.colorbar(pcm, ax=ax, format=ticker.ScalarFormatter(useMathText=True))
            colorbar_obj.set_label(heatmap_cfg.get('formula', ''))

        # 绘制等高线
        contour_data = interpolated_results.get('contour_data')
        if contour_cfg.get('enabled') and contour_data is not None and not np.all(np.isnan(contour_data)):
            cont = ax.contour(gx, gy, contour_data, 
                               levels=contour_cfg.get('levels', 10), 
                               colors=contour_cfg.get('colors', 'black'), 
                               linewidths=contour_cfg.get('linewidths', 1.0))
            if contour_cfg.get('show_labels'):
                ax.clabel(cont, inline=True, fontsize=8, fmt='%.2e')
        
        # 绘制矢量/流线图
        vector_u_data, vector_v_data = interpolated_results.get('vector_u_data'), interpolated_results.get('vector_v_data')
        if vector_cfg.get('enabled') and vector_u_data is not None and vector_v_data is not None:
            plot_type = vector_cfg.get('type', 'Quiver')
            if plot_type == 'Quiver':
                opts = vector_cfg.get('quiver_options', {}); density = opts.get('density', 10); scale = opts.get('scale', 1.0)
                sl = slice(None, None, density)
                ax.quiver(gx[sl, sl], gy[sl, sl], vector_u_data[sl, sl], vector_v_data[sl, sl], 
                          scale=scale, scale_units='xy', angles='xy', color='black')
            elif plot_type == 'Streamline':
                opts = vector_cfg.get('streamline_options', {}); density = opts.get('density', 1.0); linewidth = opts.get('linewidth', 1.0); color_by = opts.get('color_by', '速度大小')
                color_data = 'black'
                if color_by == '速度大小': color_data = np.sqrt(vector_u_data**2 + vector_v_data**2)
                elif color_by == 'U分量': color_data = vector_u_data
                elif color_by == 'V分量': color_data = vector_v_data
                stream_plot = ax.streamplot(gx, gy, vector_u_data, vector_v_data, density=density, linewidth=linewidth, color=color_data, cmap='viridis' if isinstance(color_data, np.ndarray) else None)
                if isinstance(color_data, np.ndarray) and not colorbar_obj:
                    fig.colorbar(stream_plot.lines, ax=ax).set_label(f"流线 ({color_by})")

        # --- 3. 格式化并渲染到NumPy数组 ---
        ax.set_aspect('auto', adjustable='box'); ax.grid(True, linestyle='--', alpha=0.5)
        ax.set_xlabel(self.config.get('x_axis_formula') or 'x'); ax.set_ylabel(self.config.get('y_axis_formula') or 'y')
        
        title = self.config.get('chart_title', '')
        if title: ax.set_title(title)

        formatter = ticker.ScalarFormatter(useMathText=True); formatter.set_scientific(True); formatter.set_powerlimits((-3, 3))
        ax.xaxis.set_major_formatter(formatter); ax.yaxis.set_major_formatter(formatter)

        x_min, x_max = np.nanmin(gx), np.nanmax(gx); y_min, y_max = np.nanmin(gy), np.nanmax(gy)
        xr = x_max - x_min or 1; yr = y_max - y_min or 1; m = 0.05
        ax.set_xlim(x_min - m * xr, x_max + m * xr); ax.set_ylim(y_min - m * yr, y_max + m * yr)

        canvas = FigureCanvasAgg(fig)
        canvas.draw()
        
        buf = canvas.buffer_rgba()
        image_array = np.asarray(buf)
        fig.clear()
        
        return image_array
```

**`plot_widget.py`**
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import numpy as np
import pandas as pd
import logging
import traceback
from typing import Optional, Dict, Any

from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
import matplotlib.ticker as ticker
from PyQt6.QtWidgets import QWidget, QVBoxLayout
from PyQt6.QtCore import pyqtSignal, QObject, QRunnable, QThreadPool, Qt
from PyQt6.QtGui import QCursor

from src.core.rendering_core import prepare_gridded_data

logger = logging.getLogger(__name__)

class WorkerSignals(QObject):
    finished = pyqtSignal()
    error = pyqtSignal(str)
    result = pyqtSignal(dict)

class InterpolationWorker(QRunnable):
    def __init__(self, data, config, formula_engine):
        super().__init__()
        self.data = data
        self.config = config
        self.formula_engine = formula_engine
        self.signals = WorkerSignals()
        
    def run(self):
        try:
            # 直接调用核心渲染函数
            result = prepare_gridded_data(self.data, self.config, self.formula_engine)
            self.signals.result.emit(result)
        except Exception as e:
            error_msg = f"插值或公式计算失败: {e}\n{traceback.format_exc()}"
            logger.error(error_msg)
            self.signals.error.emit(str(e))
        finally:
            self.signals.finished.emit()

class PlotWidget(QWidget):
    mouse_moved = pyqtSignal(float, float)
    probe_data_ready = pyqtSignal(dict)
    plot_rendered = pyqtSignal()
    value_picked = pyqtSignal(str, float)
    interpolation_error = pyqtSignal(str)

    def __init__(self, formula_engine, parent=None):
        super().__init__(parent)
        self.formula_engine = formula_engine
        self.figure = Figure(figsize=(12, 8), dpi=100, tight_layout=True)
        self.canvas = FigureCanvas(self.figure)
        self.ax = self.figure.add_subplot(111)
        layout = QVBoxLayout(self); layout.setContentsMargins(0,0,0,0); layout.addWidget(self.canvas)
        
        self.current_data: Optional[pd.DataFrame] = None
        self.interpolated_results: Dict[str, Any] = {}
        
        # 可视化配置
        self.x_axis_formula, self.y_axis_formula = 'x', 'y'
        self.chart_title = ""
        self.use_gpu = False
        self.heatmap_config = {'enabled': False}
        self.contour_config = {'enabled': False}
        self.vector_config = {'enabled': False}
        self.grid_resolution = (150, 150)
        
        # 绘图对象
        self.heatmap_obj = self.contour_obj = self.colorbar_obj = None
        
        # 状态
        self.is_dragging = False; self.drag_start_pos = None; self.picker_mode: Optional[str] = None
        self.last_mouse_coords: Optional[tuple[float, float]] = None
        self.thread_pool = QThreadPool(); self.is_busy_interpolating = False
        
        self._connect_signals()
        self._setup_plot_style()

    def _connect_signals(self):
        self.canvas.mpl_connect('motion_notify_event', self._on_mouse_move)
        self.canvas.mpl_connect('scroll_event', self._on_scroll)
        self.canvas.mpl_connect('button_press_event', self._on_button_press)
        self.canvas.mpl_connect('button_release_event', self._on_button_release)

    def _setup_plot_style(self):
        self.ax.set_aspect('auto', adjustable='box'); self.ax.grid(True, linestyle='--', alpha=0.5)
        self.ax.set_xlabel(self.x_axis_formula)
        self.ax.set_ylabel(self.y_axis_formula)
        
        final_title = self.chart_title
        if not final_title: # 自动生成标题
            parts = []
            if self.heatmap_config.get('enabled') and self.heatmap_config.get('formula'): parts.append(f"Heatmap of '{self.heatmap_config['formula']}'")
            if self.contour_config.get('enabled') and self.contour_config.get('formula'): parts.append(f"Contours of '{self.contour_config['formula']}'")
            if self.vector_config.get('enabled'): parts.append(f"{self.vector_config.get('type', 'Vector')} Plot")
            final_title = " and ".join(parts) if parts else "InterVis Plot"
        self.ax.set_title(final_title)

        formatter = ticker.ScalarFormatter(useMathText=True); formatter.set_scientific(True); formatter.set_powerlimits((-3, 3))
        self.ax.xaxis.set_major_formatter(formatter); self.ax.yaxis.set_major_formatter(formatter)
    
    def update_data(self, data: pd.DataFrame):
        if self.is_busy_interpolating: return
        self.current_data = data.copy(); self.is_busy_interpolating = True
        
        # 构建传递给工作线程的配置
        worker_config = {
            'x_axis_formula': self.x_axis_formula, 'y_axis_formula': self.y_axis_formula,
            'heatmap_config': self.heatmap_config, 'contour_config': self.contour_config,
            'vector_config': self.vector_config, 'use_gpu': self.use_gpu,
            'grid_resolution': self.grid_resolution
        }
        
        worker = InterpolationWorker(self.current_data, worker_config, self.formula_engine)
        worker.signals.result.connect(self._on_interpolation_result)
        worker.signals.error.connect(self._on_worker_error)
        worker.signals.finished.connect(lambda: setattr(self, 'is_busy_interpolating', False))
        self.thread_pool.start(worker)

    def _on_worker_error(self, error_message: str):
        self.is_busy_interpolating = False
        logger.error(f"插值线程错误: {error_message}")
        self.interpolation_error.emit(error_message)

    def _on_interpolation_result(self, result: dict):
        self.interpolated_results = result; self.redraw(); self.plot_rendered.emit()
        if self.last_mouse_coords:
            self.get_probe_data_at_coords(self.last_mouse_coords[0], self.last_mouse_coords[1])

    def set_config(self, **kwargs):
        self.x_axis_formula = kwargs.get('x_axis_formula', self.x_axis_formula)
        self.y_axis_formula = kwargs.get('y_axis_formula', self.y_axis_formula)
        self.chart_title = kwargs.get('chart_title', self.chart_title)
        self.use_gpu = kwargs.get('use_gpu', self.use_gpu)
        if 'heatmap_config' in kwargs: self.heatmap_config = kwargs['heatmap_config']
        if 'contour_config' in kwargs: self.contour_config = kwargs['contour_config']
        if 'vector_config' in kwargs: self.vector_config = kwargs['vector_config']

    def redraw(self):
        if not self.ax: return
        xlim, ylim = self.ax.get_xlim(), self.ax.get_ylim()
        is_initial = (xlim == (0.0, 1.0) and ylim == (0.0, 1.0))
        
        self.figure.clear(); self.ax = self.figure.add_subplot(111); self._setup_plot_style()
        self.colorbar_obj = None # 重置色条

        if self.heatmap_config.get('enabled'): self._draw_heatmap()
        if self.contour_config.get('enabled'): self._draw_contour()
        if self.vector_config.get('enabled'): self._draw_vector_plot()
        
        if not is_initial: self.ax.set_xlim(xlim); self.ax.set_ylim(ylim)
        else: self.reset_view()
            
        self.canvas.draw()
    
    def _draw_heatmap(self):
        data, gx, gy = self.interpolated_results.get('heatmap_data'), self.interpolated_results.get('grid_x'), self.interpolated_results.get('grid_y')
        if data is None or gx is None: return
        vmin_str, vmax_str = self.heatmap_config.get('vmin'), self.heatmap_config.get('vmax')
        vmin = float(vmin_str) if vmin_str is not None and str(vmin_str).strip() != '' else None
        vmax = float(vmax_str) if vmax_str is not None and str(vmax_str).strip() != '' else None
        valid = data[~np.isnan(data)]
        if valid.size > 0:
            if vmin is None: vmin = np.min(valid)
            if vmax is None: vmax = np.max(valid)

        self.heatmap_obj = self.ax.pcolormesh(gx, gy, data, cmap=self.heatmap_config.get('colormap', 'viridis'), vmin=vmin, vmax=vmax, shading='gouraud')
        self.colorbar_obj = self.figure.colorbar(self.heatmap_obj, ax=self.ax, format=ticker.ScalarFormatter(useMathText=True))
        self.colorbar_obj.set_label(self.heatmap_config.get('formula', ''))

    def _draw_contour(self):
        data, gx, gy = self.interpolated_results.get('contour_data'), self.interpolated_results.get('grid_x'), self.interpolated_results.get('grid_y')
        if data is None or gx is None or np.all(np.isnan(data)): return
        self.contour_obj = self.ax.contour(gx, gy, data, levels=self.contour_config.get('levels', 10), colors=self.contour_config.get('colors', 'black'), linewidths=self.contour_config.get('linewidths', 1.0))
        if self.contour_config.get('show_labels'): self.ax.clabel(self.contour_obj, inline=True, fontsize=8, fmt='%.2e')

    def _draw_vector_plot(self):
        if self.vector_config.get('type', 'Quiver') == 'Quiver': self._draw_quiver()
        else: self._draw_streamlines()

    def _draw_quiver(self):
        u, v, gx, gy = (self.interpolated_results.get(k) for k in ['vector_u_data', 'vector_v_data', 'grid_x', 'grid_y'])
        if u is None or v is None or gx is None: return
        opts = self.vector_config.get('quiver_options', {}); density = opts.get('density', 10); scale = opts.get('scale', 1.0)
        sl = slice(None, None, density)
        self.ax.quiver(gx[sl, sl], gy[sl, sl], u[sl, sl], v[sl, sl], scale=scale, scale_units='xy', angles='xy')

    def _draw_streamlines(self):
        u, v, gx, gy = (self.interpolated_results.get(k) for k in ['vector_u_data', 'vector_v_data', 'grid_x', 'grid_y'])
        if u is None or v is None or gx is None: return
        opts = self.vector_config.get('streamline_options', {}); density = opts.get('density', 1.5); lw = opts.get('linewidth', 1.0); color_by = opts.get('color_by', '速度大小')
        
        color_data = 'black'
        if color_by == '速度大小': color_data = np.sqrt(u**2 + v**2)
        elif color_by == 'U分量': color_data = u
        elif color_by == 'V分量': color_data = v
        
        stream_plot = self.ax.streamplot(gx, gy, u, v, density=density, linewidth=lw, color=color_data, cmap='viridis' if isinstance(color_data, np.ndarray) else None)
        if isinstance(color_data, np.ndarray) and not self.colorbar_obj:
            self.figure.colorbar(stream_plot.lines, ax=self.ax).set_label(f"流线 ({color_by})")

    def _on_mouse_move(self, event):
        if event.inaxes != self.ax or event.xdata is None: return
        self.mouse_moved.emit(event.xdata, event.ydata)
        self.last_mouse_coords = (event.xdata, event.ydata)
        if not self.is_dragging: self.get_probe_data_at_coords(event.xdata, event.ydata)
        if self.is_dragging and self.drag_start_pos:
            dx, dy = event.xdata - self.drag_start_pos[0], event.ydata - self.drag_start_pos[1]
            xlim, ylim = self.drag_start_lims
            self.ax.set_xlim(xlim[0] - dx, xlim[1] - dx); self.ax.set_ylim(ylim[0] - dy, ylim[1] - dy)
            self.canvas.draw_idle()
    
    def get_probe_data_at_coords(self, x: float, y: float):
        if self.current_data is None: return
        processed_data = self.current_data.copy()
        try:
            x_probe_values = self.formula_engine.evaluate_formula(processed_data, self.x_axis_formula)
            y_probe_values = self.formula_engine.evaluate_formula(processed_data, self.y_axis_formula)
            dist_sq = (x_probe_values - x)**2 + (y_probe_values - y)**2
            idx = dist_sq.idxmin()
            original_x, original_y = self.current_data.get('x', [0])[idx], self.current_data.get('y', [0])[idx]
            self.probe_data_ready.emit({'x': x, 'y': y, 'nearest_point': {'x': original_x, 'y': original_y}, 'variables': self.current_data.loc[idx].to_dict()})
        except Exception: return

    def _on_scroll(self, event):
        if event.inaxes != self.ax: return
        sf = 1.1 if event.step < 0 else 1/1.1
        xlim, ylim = self.ax.get_xlim(), self.ax.get_ylim(); xd, yd = event.xdata, event.ydata
        nw, nh = (xlim[1] - xlim[0]) * sf, (ylim[1] - ylim[0]) * sf
        rx, ry = (xd - xlim[0]) / (xlim[1] - xlim[0]), (yd - ylim[0]) / (ylim[1] - ylim[0])
        self.ax.set_xlim([xd - nw * rx, xd + nw * (1 - rx)]); self.ax.set_ylim([yd - nh * ry, yd + nh * (1 - ry)])
        self.canvas.draw_idle()
    
    def _on_button_press(self, event):
        if event.inaxes != self.ax: return
        if event.button == 1:
            if self.picker_mode: self._handle_picker_click(event); return
            self.is_dragging, self.drag_start_pos = True, (event.xdata, event.ydata)
            self.drag_start_lims = self.ax.get_xlim(), self.ax.get_ylim()
            self.canvas.setCursor(Qt.CursorShape.ClosedHandCursor)
        elif event.button == 3: self.reset_view()

    def _handle_picker_click(self, event):
        data, gx, gy = (self.interpolated_results.get(k) for k in ['heatmap_data', 'grid_x', 'grid_y'])
        if data is not None and gx is not None:
            try:
                from scipy.interpolate import interpn
                val = interpn((gy[:, 0], gx[0, :]), data, (event.ydata, event.xdata), method='linear', bounds_error=False, fill_value=np.nan)
                if not np.isnan(val): self.value_picked.emit(self.picker_mode, float(val))
            except Exception as e: logger.warning(f"拾取数值失败: {e}")
        self.set_picker_mode(None)

    def _on_button_release(self, event):
        if event.button == 1 and self.is_dragging: 
            self.is_dragging, self.drag_start_pos = False, None
            self.canvas.setCursor(Qt.CursorShape.ArrowCursor)

    def set_picker_mode(self, mode: Optional[str]):
        self.picker_mode = mode
        self.canvas.setCursor(QCursor(Qt.CursorShape.CrossCursor) if mode else Qt.CursorShape.ArrowCursor)
        
    def save_figure(self, filename: str, dpi: int = 300):
        try: self.figure.savefig(filename, dpi=dpi, bbox_inches='tight'); return True
        except Exception as e: logger.error(f"保存图形失败: {e}"); return False
        
    def reset_view(self):
        if self.interpolated_results and 'grid_x' in self.interpolated_results and self.interpolated_results['grid_x'] is not None:
            gx, gy = self.interpolated_results['grid_x'], self.interpolated_results['grid_y']
            x_min, x_max, y_min, y_max = np.nanmin(gx), np.nanmax(gx), np.nanmin(gy), np.nanmax(gy)
            xr = x_max - x_min or 1; yr = y_max - y_min or 1; m = 0.05
            self.ax.set_xlim(x_min - m * xr, x_max + m * xr); self.ax.set_ylim(y_min - m * yr, y_max + m * yr)
            self.canvas.draw_idle()
```

**`video_exporter.py`**
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import os, logging, time, numpy as np
from concurrent.futures import ThreadPoolExecutor, as_completed
from PyQt6.QtWidgets import QDialog, QVBoxLayout, QHBoxLayout, QLabel, QProgressBar, QPushButton, QTextEdit, QMessageBox
from PyQt6.QtCore import QThread, pyqtSignal, Qt

logger = logging.getLogger(__name__)

# 导入新的无头渲染器
from src.visualization.headless_renderer import HeadlessPlotter

class VideoExportWorker(QThread):
    progress_updated = pyqtSignal(int, int, str)
    export_finished = pyqtSignal(bool, str)
    
    def __init__(self, dm, p_conf, fname, s_f, e_f, fps):
        super().__init__()
        self.dm, self.p_conf, self.fname, self.s_f, self.fps = dm, p_conf, fname, s_f, fps
        self.e_f = min(e_f, self.dm.get_frame_count() - 1)
        self.is_cancelled = False
        self.executor = ThreadPoolExecutor(max_workers=max(1, os.cpu_count() // 2))

    def cancel(self):
        self.is_cancelled = True
        self.executor.shutdown(wait=True, cancel_futures=True)
    
    def run(self):
        try:
            total = self.e_f - self.s_f + 1
            if total <= 0: raise ValueError("帧范围无效，起始帧必须小于或等于结束帧。")
            
            frames, futures = {}, {self.executor.submit(self._render_frame, i): i for i in range(self.s_f, self.e_f + 1)}
            
            processed_count = 0
            for future in as_completed(futures):
                if self.is_cancelled: break
                idx = futures[future]
                try: 
                    result = future.result()
                    if result is not None: frames[idx] = result
                except Exception as e: 
                    logger.error(f"渲染帧 {idx} 出错: {e}")
                
                processed_count += 1
                self.progress_updated.emit(processed_count, total, f"已处理 {processed_count}/{total} 帧")

            if self.is_cancelled: 
                self.export_finished.emit(False, "导出已取消"); return

            images = [frames[i] for i in range(self.s_f, self.e_f + 1) if i in frames]
            if not images: raise ValueError("没有成功渲染任何帧。请检查日志。")

            self.progress_updated.emit(total, total, "正在编码视频...")
            self._create_video(images, self.fname, self.fps)
            self.export_finished.emit(True, f"视频已成功导出到:\n{self.fname}")

        except Exception as e: 
            logger.error(f"视频导出失败: {e}", exc_info=True)
            self.export_finished.emit(False, f"导出失败: {e}")
        finally: 
            self.executor.shutdown(wait=True, cancel_futures=True)

    def _render_frame(self, idx):
        if self.is_cancelled: return None
        data = self.dm.get_frame_data(idx)
        if data is None: raise ValueError(f"无法为帧 {idx} 加载数据")

        # 无头渲染器现在在内部创建自己的公式引擎实例
        plotter = HeadlessPlotter(self.p_conf)
        return plotter.render_frame(data, self.dm.get_variables())

    def _create_video(self, images, fname, fps):
        try:
            import moviepy.editor as mp
            logger.info(f"使用 moviepy 编码视频: {fname}")
            clips = [mp.ImageClip(m, duration=1.0/fps) for m in images]
            final_clip = mp.concatenate_videoclips(clips, method="compose")
            codec = 'libx264' if fname.lower().endswith('.mp4') else 'libvpx'
            if fname.lower().endswith('.gif'): 
                final_clip.write_gif(fname, fps=fps, logger=None)
            else: 
                final_clip.write_videofile(fname, fps=fps, codec=codec, logger='bar', threads=os.cpu_count())
        except ImportError:
            logger.warning("moviepy 未安装，尝试使用 imageio")
            import imageio
            with imageio.get_writer(fname, fps=fps, codec='libx264', quality=8, pixelformat='yuv420p', macro_block_size=1) as writer:
                for img in images: writer.append_data(img)

class VideoExportDialog(QDialog):
    def __init__(self, parent, dm, p_conf, fname, s_f, e_f, fps):
        super().__init__(parent)
        self.worker = None
        self._init_ui(fname, s_f, e_f, fps)
        self._start_export(dm, p_conf, fname, s_f, e_f, fps)
    
    def _init_ui(self, fname, s_f, e_f, fps):
        self.setWindowTitle("正在导出视频"); self.setModal(True); self.setFixedSize(450, 320)
        layout = QVBoxLayout(self)
        layout.addWidget(QLabel(f"<b>文件:</b> {os.path.basename(fname)}<br><b>帧:</b> {s_f}-{e_f} ({e_f-s_f+1}帧)<br><b>帧率:</b> {fps}fps"))
        self.progress_bar = QProgressBar(); layout.addWidget(self.progress_bar)
        self.status_label = QLabel("准备..."); layout.addWidget(self.status_label)
        self.log_text = QTextEdit(); self.log_text.setReadOnly(True); layout.addWidget(self.log_text)
        btn_layout = QHBoxLayout(); btn_layout.addStretch()
        self.cancel_btn = QPushButton("取消"); self.cancel_btn.clicked.connect(self._cancel_export); btn_layout.addWidget(self.cancel_btn)
        self.close_btn = QPushButton("关闭"); self.close_btn.clicked.connect(self.accept); self.close_btn.setEnabled(False); btn_layout.addWidget(self.close_btn)
        layout.addLayout(btn_layout)
    
    def _start_export(self, dm, p_conf, fname, s_f, e_f, fps):
        self.worker = VideoExportWorker(dm, p_conf, fname, s_f, e_f, fps)
        self.worker.progress_updated.connect(self._on_progress_updated)
        self.worker.export_finished.connect(self._on_export_finished)
        self.worker.start(); self._log("开始并行渲染...")
    
    def _cancel_export(self):
        if self.worker and self.worker.isRunning():
            self._log("正在取消..."); self.cancel_btn.setEnabled(False); self.worker.cancel()
    
    def _on_progress_updated(self, current, total, msg):
        self.progress_bar.setMaximum(total); self.progress_bar.setValue(current); self.status_label.setText(msg)
    
    def _on_export_finished(self, success, msg):
        self.status_label.setText("完成！" if success else "失败！"); self._log(msg)
        self.cancel_btn.setEnabled(False); self.close_btn.setEnabled(True)
        if success: self.progress_bar.setValue(self.progress_bar.maximum()); QMessageBox.information(self, "成功", msg)
        else: QMessageBox.warning(self, "失败", msg)
    
    def _log(self, msg): self.log_text.append(f"[{time.strftime('%H:%M:%S')}] {msg}")
    
    def closeEvent(self, event):
        if self.worker and self.worker.isRunning():
            reply = QMessageBox.question(self, "确认", "导出正在进行，确定关闭？", QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No, QMessageBox.StandardButton.No)
            if reply == QMessageBox.StandardButton.Yes: self.worker.cancel(); self.worker.wait(10000); event.accept()
            else: event.ignore()
        else: event.accept()
```

**`ui_setup.py`**
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
主窗口UI创建与布局模块
"""
import os
from PyQt6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QGridLayout,
    QSplitter, QGroupBox, QLabel, QComboBox, QLineEdit, QPushButton,
    QSlider, QSpinBox, QDoubleSpinBox, QCheckBox, QTextEdit,
    QStatusBar, QToolBar,
    QScrollArea, QTabWidget, QMenu
)
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QAction, QFont, QIcon

from src.visualization.plot_widget import PlotWidget

class UiMainWindow:
    """
    此类负责创建和布局主窗口的所有UI组件。
    """
    def setup_ui(self, main_window: QMainWindow, formula_engine):
        main_window.setWindowTitle("InterVis v1.7")
        main_window.setGeometry(100, 100, 1600, 950)
        
        # icon_path = os.path.join(os.path.dirname(__file__), '..', 'assets', 'icon.png')
        # if os.path.exists(icon_path): main_window.setWindowIcon(QIcon(icon_path))

        central_widget = QWidget()
        main_window.setCentralWidget(central_widget)
        
        main_layout = QHBoxLayout(central_widget)
        self.main_splitter = QSplitter(Qt.Orientation.Horizontal)
        main_layout.addWidget(self.main_splitter)
        
        self.plot_widget = PlotWidget(formula_engine)
        self.main_splitter.addWidget(self.plot_widget)
        
        self.control_panel = self._create_control_panel(main_window)
        self.main_splitter.addWidget(self.control_panel)
        
        self.main_splitter.setSizes([1200, 450])
        self.main_splitter.setStretchFactor(0, 1)
        
        self._create_menu_bar(main_window)
        self._create_tool_bar(main_window)
        self._create_status_bar(main_window)

    def _create_control_panel(self, parent_window) -> QWidget:
        panel = QWidget(); panel.setMaximumWidth(450); panel.setMinimumWidth(400)
        main_layout = QVBoxLayout(panel)
        self.tab_widget = QTabWidget()
        self.tab_widget.addTab(self._create_visualization_tab(parent_window), "可视化")
        self.tab_widget.addTab(self._create_probe_tab(), "数据探针")
        self.tab_widget.addTab(self._create_statistics_tab(parent_window), "全局统计")
        self.tab_widget.addTab(self._create_export_tab(parent_window), "导出与性能")
        main_layout.addWidget(self.tab_widget)
        main_layout.addWidget(self._create_playback_group())
        main_layout.addWidget(self._create_path_group())
        return panel

    def _create_formula_input(self, label_text, placeholder, parent_window, help_method):
        layout = QHBoxLayout(); line_edit = QLineEdit(); line_edit.setPlaceholderText(placeholder)
        vars_btn = QPushButton("变量"); vars_btn.setToolTip("插入可用变量或常量")
        vars_btn.clicked.connect(lambda: parent_window._show_variable_menu(line_edit, vars_btn.mapToGlobal(vars_btn.rect().bottomLeft())))
        help_btn = QPushButton("?"); help_btn.setFixedSize(25, 25); help_btn.setToolTip("打开公式使用指南 (F1)"); help_btn.clicked.connect(help_method)
        layout.addWidget(line_edit); layout.addWidget(vars_btn); layout.addWidget(help_btn)
        return QLabel(label_text), layout, line_edit
    
    def _create_visualization_tab(self, parent_window) -> QWidget:
        tab = QWidget(); layout = QVBoxLayout(tab); scroll_area = QScrollArea(); scroll_widget = QWidget(); scroll_layout = QVBoxLayout(scroll_widget)
        
        axis_group = QGroupBox("坐标轴与标题"); axis_layout = QGridLayout(axis_group)
        title_label, title_layout, self.chart_title_edit = self._create_formula_input("图表标题:", "自动生成 (可自定义)", parent_window, lambda: parent_window._show_formula_help("axis_title"))
        axis_layout.addWidget(title_label, 0, 0); axis_layout.addLayout(title_layout, 0, 1)
        x_label, x_layout, self.x_axis_formula = self._create_formula_input("X轴公式:", "默认为 'x'", parent_window, parent_window._show_formula_help)
        axis_layout.addWidget(x_label, 1, 0); axis_layout.addLayout(x_layout, 1, 1)
        y_label, y_layout, self.y_axis_formula = self._create_formula_input("Y轴公式:", "默认为 'y'", parent_window, parent_window._show_formula_help)
        axis_layout.addWidget(y_label, 2, 0); axis_layout.addLayout(y_layout, 2, 1)
        scroll_layout.addWidget(axis_group)

        heatmap_group = QGroupBox("背景热力图"); heatmap_group.setCheckable(True); self.heatmap_enabled = heatmap_group; h_layout = QGridLayout(heatmap_group)
        heat_label, heat_layout, self.heatmap_formula = self._create_formula_input("公式:", "例: sqrt(u**2 + v**2)", parent_window, parent_window._show_formula_help)
        h_layout.addWidget(heat_label, 0, 0); h_layout.addLayout(heat_layout, 0, 1)
        h_layout.addWidget(QLabel("颜色映射:"), 1, 0); self.heatmap_colormap = QComboBox(); self.heatmap_colormap.addItems(['viridis', 'plasma', 'inferno', 'magma', 'jet', 'coolwarm', 'RdBu_r']); h_layout.addWidget(self.heatmap_colormap, 1, 1)
        min_layout = QHBoxLayout(); self.heatmap_vmin = QLineEdit(); self.pick_vmin_btn = QPushButton("拾取"); self.pick_vmin_btn.clicked.connect(lambda: self.plot_widget.set_picker_mode('vmin')); min_layout.addWidget(self.heatmap_vmin); min_layout.addWidget(self.pick_vmin_btn)
        max_layout = QHBoxLayout(); self.heatmap_vmax = QLineEdit(); self.pick_vmax_btn = QPushButton("拾取"); self.pick_vmax_btn.clicked.connect(lambda: self.plot_widget.set_picker_mode('vmax')); max_layout.addWidget(self.heatmap_vmax); max_layout.addWidget(self.pick_vmax_btn)
        h_layout.addWidget(QLabel("最小值:"), 2, 0); h_layout.addLayout(min_layout, 2, 1); h_layout.addWidget(QLabel("最大值:"), 3, 0); h_layout.addLayout(max_layout, 3, 1)
        scroll_layout.addWidget(heatmap_group)
        
        contour_group = QGroupBox("前景等高线"); contour_group.setCheckable(True); self.contour_enabled = contour_group; c_layout = QGridLayout(contour_group)
        contour_label, contour_layout, self.contour_formula = self._create_formula_input("公式:", "例: p - mean(p)", parent_window, parent_window._show_formula_help)
        c_layout.addWidget(contour_label, 0, 0); c_layout.addLayout(contour_layout, 0, 1)
        c_layout.addWidget(QLabel("等高线数:"), 1, 0); self.contour_levels = QSpinBox(); self.contour_levels.setRange(2, 100); self.contour_levels.setValue(10); c_layout.addWidget(self.contour_levels, 1, 1)
        c_layout.addWidget(QLabel("线条颜色:"), 2, 0); self.contour_colors = QComboBox(); self.contour_colors.addItems(['black', 'white', 'red', 'blue', 'grey']); c_layout.addWidget(self.contour_colors, 2, 1)
        c_layout.addWidget(QLabel("线条宽度:"), 3, 0); self.contour_linewidth = QDoubleSpinBox(); self.contour_linewidth.setRange(0.1, 10.0); self.contour_linewidth.setValue(1.0); self.contour_linewidth.setSingleStep(0.1); c_layout.addWidget(self.contour_linewidth, 3, 1)
        self.contour_labels = QCheckBox("显示数值标签"); self.contour_labels.setChecked(True); c_layout.addWidget(self.contour_labels, 4, 0, 1, 2)
        scroll_layout.addWidget(contour_group)

        vector_group = QGroupBox("矢量/流线图"); vector_group.setCheckable(True); self.vector_enabled = vector_group; v_layout = QGridLayout(vector_group)
        v_layout.addWidget(QLabel("绘图类型:"), 0, 0); self.vector_plot_type = QComboBox(); self.vector_plot_type.addItems(["流线图 (Streamline)", "矢量图 (Quiver)"]); v_layout.addWidget(self.vector_plot_type, 0, 1)
        u_label, u_layout, self.vector_u_formula = self._create_formula_input("U分量公式:", "例: u - u_global_mean", parent_window, parent_window._show_formula_help)
        v_label, v_layout_input, self.vector_v_formula = self._create_formula_input("V分量公式:", "例: v - v_global_mean", parent_window, parent_window._show_formula_help)
        v_layout.addWidget(u_label, 1, 0); v_layout.addLayout(u_layout, 1, 1); v_layout.addWidget(v_label, 2, 0); v_layout.addLayout(v_layout_input, 2, 1)
        
        self.quiver_options_group = QGroupBox("矢量图选项"); quiver_layout = QGridLayout(self.quiver_options_group)
        quiver_layout.addWidget(QLabel("矢量密度:"), 0, 0); self.quiver_density_spinbox = QSpinBox(); self.quiver_density_spinbox.setRange(1, 50); self.quiver_density_spinbox.setValue(10); quiver_layout.addWidget(self.quiver_density_spinbox, 0, 1)
        quiver_layout.addWidget(QLabel("矢量缩放:"), 1, 0); self.quiver_scale_spinbox = QDoubleSpinBox(); self.quiver_scale_spinbox.setRange(0.1, 100.0); self.quiver_scale_spinbox.setValue(1.0); quiver_layout.addWidget(self.quiver_scale_spinbox, 1, 1)
        v_layout.addWidget(self.quiver_options_group, 3, 0, 1, 2)

        self.streamline_options_group = QGroupBox("流线图选项"); stream_layout = QGridLayout(self.streamline_options_group)
        stream_layout.addWidget(QLabel("流线密度:"), 0, 0); self.stream_density_spinbox = QDoubleSpinBox(); self.stream_density_spinbox.setRange(0.2, 10.0); self.stream_density_spinbox.setValue(1.5); stream_layout.addWidget(self.stream_density_spinbox, 0, 1)
        stream_layout.addWidget(QLabel("流线线宽:"), 1, 0); self.stream_linewidth_spinbox = QDoubleSpinBox(); self.stream_linewidth_spinbox.setRange(0.2, 10.0); self.stream_linewidth_spinbox.setValue(1.0); stream_layout.addWidget(self.stream_linewidth_spinbox, 1, 1)
        stream_layout.addWidget(QLabel("流线颜色:"), 2, 0); self.stream_color_combo = QComboBox(); self.stream_color_combo.addItems(["速度大小", "U分量", "V分量", "黑色"]); stream_layout.addWidget(self.stream_color_combo, 2, 1)
        v_layout.addWidget(self.streamline_options_group, 4, 0, 1, 2)
        scroll_layout.addWidget(vector_group)
        
        scroll_layout.addStretch(); scroll_widget.setLayout(scroll_layout); scroll_area.setWidget(scroll_widget); scroll_area.setWidgetResizable(True); layout.addWidget(scroll_area)
        return tab

    def _create_probe_tab(self) -> QWidget:
        tab = QWidget(); layout = QVBoxLayout(tab); probe_group = QGroupBox("探针信息"); probe_layout = QVBoxLayout(probe_group)
        coord_layout = QHBoxLayout(); coord_layout.addWidget(QLabel("鼠标坐标:")); self.probe_coord_label = QLabel("(0.00, 0.00)")
        self.probe_coord_label.setFont(QFont("monospace")); coord_layout.addWidget(self.probe_coord_label); coord_layout.addStretch(); probe_layout.addLayout(coord_layout)
        self.probe_text = QTextEdit(); self.probe_text.setReadOnly(True); self.probe_text.setFont(QFont("Courier New", 9)); self.probe_text.setLineWrapMode(QTextEdit.LineWrapMode.NoWrap)
        probe_layout.addWidget(self.probe_text); layout.addWidget(probe_group); layout.addStretch(); return tab
        
    def _create_statistics_tab(self, parent_window) -> QWidget:
        tab = QWidget(); main_layout = QVBoxLayout(tab)
        basic_group = QGroupBox("基础统计"); basic_layout = QVBoxLayout(basic_group)
        info_label = QLabel("计算所有数据文件中每个原始变量的全局统计特征(均值、标准差等)。\n这些特征将作为常量在公式中使用。"); info_label.setWordWrap(True); basic_layout.addWidget(info_label)
        action_layout = QHBoxLayout(); self.calc_basic_stats_btn = QPushButton("开始计算基础统计"); self.export_stats_btn = QPushButton("导出统计结果"); self.export_stats_btn.setEnabled(False)
        action_layout.addWidget(self.calc_basic_stats_btn); action_layout.addWidget(self.export_stats_btn); basic_layout.addLayout(action_layout); main_layout.addWidget(basic_group)
        
        custom_group = QGroupBox("自定义常量计算"); custom_layout = QVBoxLayout(custom_group)
        custom_header_layout = QHBoxLayout(); custom_info = QLabel("在此定义新的全局常量，每行一个。格式: <code>new_name = agg_func(expr)</code>"); custom_info.setTextFormat(Qt.TextFormat.RichText); custom_info.setWordWrap(True)
        custom_header_layout.addWidget(custom_info, 1); custom_help_btn = QPushButton("?"); custom_help_btn.setFixedSize(25, 25); self.custom_stats_help_action = QAction(); custom_help_btn.setAction(self.custom_stats_help_action)
        custom_header_layout.addWidget(custom_help_btn); custom_layout.addLayout(custom_header_layout)
        self.custom_stats_input = QTextEdit(); self.custom_stats_input.setFont(QFont("Courier New", 9)); self.custom_stats_input.setPlaceholderText("示例:\ntke_global = mean(0.5 * (u**2 + v**2))")
        self.custom_stats_input.setFixedHeight(100); custom_layout.addWidget(self.custom_stats_input)
        self.calc_custom_stats_btn = QPushButton("计算自定义常量"); self.calc_custom_stats_btn.setEnabled(False); custom_btn_layout = QHBoxLayout(); custom_btn_layout.addStretch(); custom_btn_layout.addWidget(self.calc_custom_stats_btn); custom_layout.addLayout(custom_btn_layout)
        main_layout.addWidget(custom_group)

        results_group = QGroupBox("计算结果"); results_layout = QVBoxLayout(results_group)
        self.stats_results_text = QTextEdit(); self.stats_results_text.setReadOnly(True); self.stats_results_text.setFont(QFont("Courier New", 9)); self.stats_results_text.setText("尚未计算。")
        results_layout.addWidget(self.stats_results_text); main_layout.addWidget(results_group); main_layout.addStretch(); return tab

    def _create_export_tab(self, parent_window) -> QWidget:
        tab = QWidget(); layout = QVBoxLayout(tab)
        cfg_group = QGroupBox("设置管理"); cfg_layout = QGridLayout(cfg_group)
        cfg_layout.addWidget(QLabel("配置文件:"), 0, 0); self.config_combo = QComboBox(); cfg_layout.addWidget(self.config_combo, 0, 1, 1, 2)
        btn_layout = QHBoxLayout(); self.save_config_btn = QPushButton("保存"); self.save_config_as_btn = QPushButton("另存为..."); btn_layout.addWidget(self.save_config_btn); btn_layout.addWidget(self.save_config_as_btn); cfg_layout.addLayout(btn_layout, 1, 1, 1, 2)
        self.config_status_label = QLabel(""); self.config_status_label.setStyleSheet("color: orange;"); cfg_layout.addWidget(self.config_status_label, 2, 0, 1, 3); layout.addWidget(cfg_group)

        export_group = QGroupBox("导出"); export_layout = QGridLayout(export_group)
        export_layout.addWidget(QLabel("分辨率(DPI):"), 0, 0); self.export_dpi = QSpinBox(); self.export_dpi.setRange(100, 1200); self.export_dpi.setValue(300); export_layout.addWidget(self.export_dpi, 0, 1)
        self.export_img_btn = QPushButton("保存当前帧图片"); export_layout.addWidget(self.export_img_btn, 1, 0, 1, 2)
        export_layout.addWidget(QLabel("帧率(FPS):"), 2, 0); self.video_fps = QSpinBox(); self.video_fps.setRange(1, 60); self.video_fps.setValue(15); export_layout.addWidget(self.video_fps, 2, 1)
        export_layout.addWidget(QLabel("起始帧:"), 3, 0); self.video_start_frame = QSpinBox(); self.video_start_frame.setMinimum(0); export_layout.addWidget(self.video_start_frame, 3, 1)
        export_layout.addWidget(QLabel("结束帧:"), 4, 0); self.video_end_frame = QSpinBox(); self.video_end_frame.setMinimum(0); export_layout.addWidget(self.video_end_frame, 4, 1)
        export_layout.addWidget(QLabel("渲染网格:"), 5, 0); grid_res_layout = QHBoxLayout()
        self.video_grid_w = QSpinBox(); self.video_grid_w.setRange(50, 2000); self.video_grid_w.setValue(300); grid_res_layout.addWidget(self.video_grid_w)
        grid_res_layout.addWidget(QLabel("x")); self.video_grid_h = QSpinBox(); self.video_grid_h.setRange(50, 2000); self.video_grid_h.setValue(300); grid_res_layout.addWidget(self.video_grid_h)
        export_layout.addLayout(grid_res_layout, 5, 1); self.export_vid_btn = QPushButton("导出视频"); export_layout.addWidget(self.export_vid_btn, 6, 0, 1, 2)
        self.batch_export_btn = QPushButton("批量视频导出..."); export_layout.addWidget(self.batch_export_btn, 7, 0, 1, 2); layout.addWidget(export_group)
        
        perf_group = QGroupBox("性能"); perf_layout = QVBoxLayout(perf_group); self.gpu_checkbox = QCheckBox("启用GPU加速 (需NVIDIA/CuPy)")
        perf_layout.addWidget(self.gpu_checkbox); cache_layout = QHBoxLayout(); cache_layout.addWidget(QLabel("内存缓存:"))
        self.cache_size_spinbox = QSpinBox(); self.cache_size_spinbox.setRange(10, 2000); self.cache_size_spinbox.setValue(100); cache_layout.addWidget(self.cache_size_spinbox)
        self.apply_cache_btn = QPushButton("应用"); cache_layout.addWidget(self.apply_cache_btn); perf_layout.addLayout(cache_layout); layout.addWidget(perf_group); layout.addStretch(); return tab

    def _create_playback_group(self) -> QGroupBox:
        group = QGroupBox("播放控制"); layout = QVBoxLayout(group); info_layout = QHBoxLayout(); self.frame_info_label = QLabel("帧: 0/0")
        info_layout.addWidget(self.frame_info_label); info_layout.addStretch(); self.timestamp_label = QLabel("时间戳: 0.0"); info_layout.addWidget(self.timestamp_label); layout.addLayout(info_layout)
        self.time_slider = QSlider(Qt.Orientation.Horizontal); self.time_slider.setMinimum(0); layout.addWidget(self.time_slider)
        btns_layout = QHBoxLayout(); self.play_button = QPushButton("播放"); btns_layout.addWidget(self.play_button); self.prev_btn = QPushButton("<<"); btns_layout.addWidget(self.prev_btn)
        self.next_btn = QPushButton(">>"); btns_layout.addWidget(self.next_btn); self.refresh_button = QPushButton("立即刷新"); btns_layout.addWidget(self.refresh_button); btns_layout.addSpacing(20)
        btns_layout.addWidget(QLabel("跳帧:")); self.frame_skip_spinbox = QSpinBox(); self.frame_skip_spinbox.setRange(1, 100); self.frame_skip_spinbox.setValue(1); btns_layout.addWidget(self.frame_skip_spinbox)
        layout.addLayout(btns_layout); return group

    def _create_path_group(self) -> QGroupBox:
        group = QGroupBox("路径设置"); layout = QGridLayout(group)
        layout.addWidget(QLabel("数据目录:"), 0, 0); self.data_dir_line_edit = QLineEdit(); self.data_dir_line_edit.setReadOnly(True); layout.addWidget(self.data_dir_line_edit, 0, 1)
        self.change_data_dir_btn = QPushButton("..."); layout.addWidget(self.change_data_dir_btn, 0, 2)
        layout.addWidget(QLabel("输出目录:"), 1, 0); self.output_dir_line_edit = QLineEdit(); self.output_dir_line_edit.setReadOnly(True); layout.addWidget(self.output_dir_line_edit, 1, 1)
        self.change_output_dir_btn = QPushButton("..."); layout.addWidget(self.change_output_dir_btn, 1, 2); return group
    
    def _create_menu_bar(self, main_window: QMainWindow):
        menubar = main_window.menuBar()
        file_menu = menubar.addMenu('文件(&F)'); self.open_data_dir_action = QAction('打开数据目录...', main_window); self.set_output_dir_action = QAction('设置输出目录...', main_window)
        self.reload_action = QAction('重新加载数据', main_window); self.reload_action.setShortcut('Ctrl+R'); self.save_config_action = QAction('保存设置', main_window); self.save_config_action.setShortcut('Ctrl+S')
        self.save_config_as_action = QAction('设置另存为...', main_window); self.save_config_as_action.setShortcut('Ctrl+Shift+S'); self.new_config_action = QAction('新建设置...', main_window); self.new_config_action.setShortcut('Ctrl+N')
        self.exit_action = QAction('退出', main_window); self.exit_action.setShortcut('Ctrl+Q')
        file_menu.addAction(self.open_data_dir_action); file_menu.addAction(self.set_output_dir_action); file_menu.addAction(self.reload_action); file_menu.addSeparator()
        file_menu.addAction(self.save_config_action); file_menu.addAction(self.save_config_as_action); file_menu.addAction(self.new_config_action); file_menu.addSeparator(); file_menu.addAction(self.exit_action)
        
        view_menu = menubar.addMenu('视图(&V)'); self.reset_view_action = QAction('重置视图', main_window); self.reset_view_action.setShortcut('Ctrl+0')
        self.toggle_panel_action = QAction('显示/隐藏控制面板', main_window); self.toggle_panel_action.setShortcut('F4'); self.toggle_panel_action.setCheckable(True); self.toggle_panel_action.setChecked(True)
        self.full_screen_action = QAction('全屏', main_window); self.full_screen_action.setShortcut('F11'); self.full_screen_action.setCheckable(True)
        view_menu.addAction(self.reset_view_action); view_menu.addSeparator(); view_menu.addAction(self.toggle_panel_action); view_menu.addAction(self.full_screen_action)
        
        help_menu = menubar.addMenu('帮助(&H)'); self.formula_help_action = QAction('公式指南', main_window); self.formula_help_action.setShortcut('F1')
        self.about_action = QAction('关于 InterVis', main_window)
        help_menu.addAction(self.formula_help_action); help_menu.addAction(self.custom_stats_help_action); help_menu.addSeparator(); help_menu.addAction(self.about_action)

    def _create_tool_bar(self, main_window: QMainWindow):
        self.toolbar = QToolBar("MainToolBar"); self.toolbar.setObjectName("MainToolBar"); main_window.addToolBar(self.toolbar)
        self.toolbar.addAction(self.open_data_dir_action); self.toolbar.addAction(self.reload_action); self.toolbar.addSeparator()
        self.toolbar.addAction(self.save_config_action); self.toolbar.addSeparator(); self.toolbar.addAction(self.reset_view_action)
        self.reset_view_action.setToolTip("重置缩放和平移 (Ctrl+0)")

    def _create_status_bar(self, main_window: QMainWindow):
        self.status_bar = QStatusBar(); main_window.setStatusBar(self.status_bar)
        self.cache_label = QLabel("缓存: 0/100"); self.status_bar.addPermanentWidget(self.cache_label)
        self.gpu_status_label = QLabel("GPU: 检测中..."); self.status_bar.addPermanentWidget(self.gpu_status_label)
        self.status_bar.showMessage("准备就绪")
```

**`data_manager.py`**
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import os
import pandas as pd
import logging
from typing import Optional, List, Dict, Any, Generator
from collections import OrderedDict
from PyQt6.QtCore import QObject, pyqtSignal

logger = logging.getLogger(__name__)

class DataManager(QObject):
    """
    负责数据文件的索引、加载和缓存。
    不再负责统计计算。
    """
    loading_finished = pyqtSignal(bool, str)
    error_occurred = pyqtSignal(str)
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.data_directory: Optional[str] = None
        self.file_index: List[Dict[str, Any]] = []
        self.cache: OrderedDict[int, pd.DataFrame] = OrderedDict()
        self.cache_max_size = 100
        self.variables: List[str] = []
        self.global_stats: Dict[str, float] = {}

    def initialize(self, directory: str):
        self.data_directory = directory
        if not os.path.isdir(self.data_directory):
            msg = f"数据目录不存在: {self.data_directory}"; logger.error(msg); self.error_occurred.emit(msg); return
        
        self.clear_all()
        logger.info(f"开始扫描数据目录: {self.data_directory}")
        try:
            csv_files = sorted([f for f in os.listdir(self.data_directory) if f.lower().endswith('.csv')])
            if not csv_files:
                logger.warning("目录中未找到CSV文件。"); self.loading_finished.emit(False, "目录中无CSV文件"); return
            
            for filename in csv_files:
                self.file_index.append({'path': os.path.join(self.data_directory, filename), 'timestamp': len(self.file_index)})
            
            # 从第一个文件中读取数值列作为变量列表
            df_sample = pd.read_csv(self.file_index[0]['path'], nrows=5)
            self.variables = [col for col in df_sample.columns if pd.api.types.is_numeric_dtype(df_sample[col])]
            
            logger.info(f"数据变量已识别 (仅数值类型): {self.variables}")
            msg = f"成功加载 {len(self.file_index)} 帧索引"; logger.info(msg); self.loading_finished.emit(True, msg)
        except Exception as e:
            msg = f"扫描数据目录失败: {e}"; logger.error(msg, exc_info=True); self.error_occurred.emit(msg)

    def get_frame_data(self, frame_index: int) -> Optional[pd.DataFrame]:
        if not (0 <= frame_index < len(self.file_index)): return None
        if frame_index in self.cache:
            self.cache.move_to_end(frame_index)
            return self.cache[frame_index]
        try:
            data = pd.read_csv(self.file_index[frame_index]['path'], usecols=self.variables)
            self.cache[frame_index] = data
            self._enforce_cache_limit()
            return data
        except Exception as e:
            msg = f"加载帧 {frame_index} 数据失败: {e}"; logger.error(msg, exc_info=True)
            self.error_occurred.emit(f"加载文件失败: {os.path.basename(self.file_index[frame_index]['path'])}")
            return None

    def iter_dataframes(self, use_cols: Optional[List[str]] = None) -> Generator[pd.DataFrame, None, None]:
        """
        一个生成器，用于逐个迭代处理所有数据文件，避免一次性加载到内存。
        主要由 StatisticsCalculator 使用。
        """
        if use_cols is None: use_cols = self.variables
        for file_info in self.file_index:
            try:
                # 为了性能，只读取需要的列
                yield pd.read_csv(file_info['path'], usecols=use_cols)
            except Exception as e:
                logger.error(f"迭代读取文件 {file_info['path']} 时出错: {e}")
                continue # 跳过坏文件

    def _enforce_cache_limit(self):
        while len(self.cache) > self.cache_max_size:
            self.cache.popitem(last=False)

    def set_cache_size(self, size: int):
        self.cache_max_size = max(1, size)
        self._enforce_cache_limit()
        logger.info(f"缓存大小已设置为: {self.cache_max_size}")

    def get_frame_count(self) -> int: return len(self.file_index)
    def get_frame_info(self, i: int) -> Optional[Dict[str, Any]]: return self.file_index[i] if 0 <= i < len(self.file_index) else None
    def get_cache_info(self) -> Dict: return {'size': len(self.cache), 'max_size': self.cache_max_size}
    def get_variables(self) -> List[str]: return self.variables
    
    def clear_all(self): 
        self.file_index.clear(); self.cache.clear(); self.variables.clear(); self.global_stats.clear()

    def clear_global_stats(self):
        """清空已计算的全局统计数据"""
        self.global_stats.clear()
        logger.info("全局统计数据已清除。")
```

**`formula_validator.py` 已重命名并移动到 `src/core/formula_engine.py`**
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
公式引擎模块
"""
import ast
import re
import logging
import pandas as pd
from typing import Set, List, Dict, Any

logger = logging.getLogger(__name__)

class FormulaEngine:
    """负责验证、解析和评估用户定义的数学公式。"""
    def __init__(self):
        # 允许的操作符和函数
        self.allowed_op_types = {ast.Add, ast.Sub, ast.Mult, ast.Div, ast.Pow, ast.USub, ast.UAdd}
        self.allowed_functions = {'sin', 'cos', 'tan', 'asin', 'acos', 'atan', 'sinh', 'cosh', 'tanh', 'exp', 'log', 'log10', 'sqrt', 'abs', 'floor', 'ceil', 'round', 'min', 'max'}
        self.allowed_aggregates = {'mean', 'sum', 'median', 'std', 'var', 'min_frame', 'max_frame'}

        # 内置常量
        self.science_constants = {
            'pi': 3.141592653589793, 'e': 2.718281828459045, 'g': 9.80665,
            'c': 299792458, 'h': 6.62607015e-34, 'k_B': 1.380649e-23,
            'N_A': 6.02214076e23, 'R': 8.314462618,
        }
        
        # 动态变量
        self.allowed_variables: Set[str] = set()
        self.custom_global_variables: Dict[str, float] = {}
    
    def update_allowed_variables(self, variables: List[str]):
        self.allowed_variables = set(variables)
        logger.debug(f"公式引擎已更新可用变量: {self.allowed_variables}")

    def update_custom_global_variables(self, global_vars: Dict[str, float]):
        self.custom_global_variables = global_vars
        logger.debug(f"公式引擎已更新全局变量: {list(self.custom_global_variables.keys())}")

    def get_all_constants_and_globals(self) -> Dict:
        return {**self.science_constants, **self.custom_global_variables}

    def validate(self, formula: str) -> bool:
        if not formula.strip(): return True
        try:
            tree = ast.parse(formula, mode='eval')
            return self._validate_node(tree.body)
        except Exception as e:
            logger.warning(f"公式验证失败: '{formula}' - {e}")
            return False
    
    def _validate_node(self, node) -> bool:
        if isinstance(node, ast.Constant): return isinstance(node.value, (int, float, complex))
        if isinstance(node, (ast.Num, ast.NameConstant)): return True
        if isinstance(node, ast.Name): 
            return (node.id in self.allowed_variables or 
                    node.id in self.science_constants or
                    node.id in self.custom_global_variables or
                    node.id in self.allowed_functions)
        if isinstance(node, ast.BinOp): return type(node.op) in self.allowed_op_types and self._validate_node(node.left) and self._validate_node(node.right)
        if isinstance(node, ast.UnaryOp): return type(node.op) in self.allowed_op_types and self._validate_node(node.operand)
        if isinstance(node, ast.Call):
            func_name = getattr(node.func, 'id', None)
            if func_name in self.allowed_functions:
                return all(self._validate_node(arg) for arg in node.args)
            if func_name in self.allowed_aggregates:
                return len(node.args) == 1 and self._validate_node(node.args[0])
        return False
            
    def get_used_variables(self, formula: str) -> Set[str]:
        if not self.validate(formula): return set()
        tree = ast.parse(formula, mode='eval')
        return {node.id for node in ast.walk(tree) if isinstance(node, ast.Name) and node.id in self.allowed_variables}

    def evaluate_formula(self, data: pd.DataFrame, formula: str) -> pd.Series:
        if not formula: raise ValueError("传入了空公式")

        eval_globals = self.get_all_constants_and_globals()
        local_scope = eval_globals.copy()
        processed_formula = formula
        
        # 1. 预处理聚合函数
        agg_pattern = re.compile(r'(\b(?:' + '|'.join(self.allowed_aggregates) + r'))\s*\((.*?)\)')
        matches = list(agg_pattern.finditer(formula))
        for i, match in enumerate(reversed(matches)):
            agg_func_name, inner_expr = match.groups()
            if inner_expr.count('(') != inner_expr.count(')'): continue # 简单括号匹配
            
            try:
                inner_values = data.eval(inner_expr, global_dict=eval_globals, local_dict={})
            except Exception as e:
                raise ValueError(f"评估聚合函数内表达式 '{inner_expr}' 时出错: {e}")

            if agg_func_name == 'mean': scalar_result = inner_values.mean()
            elif agg_func_name == 'sum': scalar_result = inner_values.sum()
            elif agg_func_name == 'median': scalar_result = inner_values.median()
            elif agg_func_name == 'std': scalar_result = inner_values.std()
            elif agg_func_name == 'var': scalar_result = inner_values.var()
            elif agg_func_name == 'min_frame': scalar_result = inner_values.min()
            elif agg_func_name == 'max_frame': scalar_result = inner_values.max()
            else: scalar_result = 0.0

            temp_var_name = f"__agg_result_{len(matches) - 1 - i}__"
            local_scope[temp_var_name] = scalar_result
            processed_formula = processed_formula[:match.start()] + f"@{temp_var_name}" + processed_formula[match.end():]

        # 2. 为所有外部变量添加 '@' 前缀以供 pandas.eval 使用
        all_external_vars = sorted(eval_globals.keys(), key=len, reverse=True)
        for var_name in all_external_vars:
            pattern = r'\b' + re.escape(var_name) + r'\b'
            replacement = '@' + var_name
            processed_formula = re.sub(pattern, replacement, processed_formula)

        # 3. 最终求值
        try:
            logger.debug(f"原始公式: '{formula}', 处理后公式: '{processed_formula}', 作用域: {list(local_scope.keys())}")
            return data.eval(processed_formula, global_dict={}, local_dict=local_scope)
        except Exception as e:
            raise ValueError(f"评估最终公式 '{processed_formula}' 时失败: {e}")
```

**`workers.py`**
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
后台工作线程模块
"""
import os
import json
import logging
from typing import List, Dict
from datetime import datetime

from PyQt6.QtCore import QThread, pyqtSignal, QEventLoop

from src.core.data_manager import DataManager
from src.core.statistics_calculator import StatisticsCalculator
from src.visualization.video_exporter import VideoExportWorker

logger = logging.getLogger(__name__)

# --- 批量导出功能 ---

class BatchExportWorker(QThread):
    progress = pyqtSignal(int, int, str)
    log_message = pyqtSignal(str)
    finished = pyqtSignal(str)

    def __init__(self, config_files: List[str], data_manager: DataManager, output_dir: str, parent=None):
        super().__init__(parent)
        self.config_files = config_files
        self.data_manager = data_manager
        self.output_dir = output_dir
        self.is_cancelled = False

    def run(self):
        successful, failed = 0, 0
        total = len(self.config_files)

        for i, filepath in enumerate(self.config_files):
            if self.is_cancelled: break
            
            filename = os.path.basename(filepath)
            self.progress.emit(i, total, filename)
            self.log_message.emit(f"正在读取配置文件: {filename}")

            try:
                with open(filepath, 'r', encoding='utf-8') as f: config = json.load(f)
                
                axes_cfg, export_cfg = config.get('axes', {}), config.get("export", {})
                
                p_conf = {
                    'x_axis_formula': axes_cfg.get('x_formula', 'x'), 'y_axis_formula': axes_cfg.get('y_formula', 'y'),
                    'chart_title': axes_cfg.get('title', ''), 'use_gpu': config.get('performance', {}).get('gpu', False),
                    'heatmap_config': config.get('heatmap', {}), 'contour_config': config.get('contour', {}),
                    'vector_config': config.get('vector', {}),
                    'grid_resolution': (export_cfg.get("video_grid_w", 300), export_cfg.get("video_grid_h", 300)),
                    'export_dpi': export_cfg.get("dpi", 300), 'global_scope': self.data_manager.global_stats
                }
                
                s_f = export_cfg.get("video_start_frame", 0)
                e_f = export_cfg.get("video_end_frame", self.data_manager.get_frame_count() - 1)
                fps = export_cfg.get("video_fps", 15)

                if s_f >= e_f: raise ValueError("起始帧必须小于结束帧")

                config_name = os.path.splitext(filename)[0]
                out_fname = os.path.join(self.output_dir, f"batch_{config_name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.mp4")
                self.log_message.emit(f"准备导出视频: {os.path.basename(out_fname)}")
                
                video_worker = VideoExportWorker(self.data_manager, p_conf, out_fname, s_f, e_f, fps)
                loop = QEventLoop()
                export_success, export_message = False, ""

                def on_video_finished(success, msg):
                    nonlocal export_success, export_message
                    export_success, export_message = success, msg
                    loop.quit()

                video_worker.export_finished.connect(on_video_finished)
                video_worker.progress_updated.connect(lambda cur, tot, msg: self.log_message.emit(f"  └ {msg}"))
                video_worker.start(); loop.exec(); video_worker.deleteLater()

                if export_success: self.log_message.emit(f"成功: {filename}"); successful += 1
                else: self.log_message.emit(f"失败: {filename}. 原因: {export_message}"); failed += 1

            except Exception as e:
                self.log_message.emit(f"处理 '{filename}' 时发生严重错误: {e}"); failed += 1
        
        self.finished.emit(f"成功导出 {successful} 个视频，失败 {failed} 个。")

    def cancel(self): self.is_cancelled = True

# --- 全局统计功能 ---

class GlobalStatsWorker(QThread):
    progress = pyqtSignal(int, int)
    finished = pyqtSignal(dict)
    error = pyqtSignal(str)

    def __init__(self, data_manager: DataManager, parent=None):
        super().__init__(parent)
        self.calculator = StatisticsCalculator(data_manager)

    def run(self):
        try:
            results = self.calculator.calculate_global_stats(lambda c, t: self.progress.emit(c, t))
            self.finished.emit(results)
        except Exception as e:
            logger.error(f"全局统计计算失败: {e}", exc_info=True)
            self.error.emit(str(e))

class CustomGlobalStatsWorker(QThread):
    progress = pyqtSignal(int, int, str)
    finished = pyqtSignal(dict)
    error = pyqtSignal(str)

    def __init__(self, data_manager: DataManager, definitions: List[str], parent=None):
        super().__init__(parent)
        self.calculator = StatisticsCalculator(data_manager)
        self.definitions = definitions
        self.data_manager = data_manager

    def run(self):
        try:
            # 自定义统计需要基础统计作为输入
            base_stats = self.data_manager.global_stats
            if not base_stats:
                raise RuntimeError("计算自定义常量前，必须先计算基础统计数据。")
            
            results = self.calculator.calculate_custom_global_stats(
                self.definitions, base_stats, lambda c, t, m: self.progress.emit(c, t, m)
            )
            self.finished.emit(results)
        except Exception as e:
            logger.error(f"自定义全局常量计算失败: {e}", exc_info=True)
            self.error.emit(str(e))
```